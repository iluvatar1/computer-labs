#+TITLE:Computer room in slackware : Server and client config
#+AUTHOR: William Oquendo
#+email: woquendo@gmail.com
#+INFOJS_OPT: 
#+BABEL: :session *R* :cache yes :results output graphics :exports both :tangle yes 
-----

This document presents a basic procedure to configure a computer room
in slackware. This generates a script, called
=bootsrap_slackware.sh= that uses a bunch of config files to setup
either a client or a server. At the end
you just run the mentioned script and hopefully everything will work
as expected. 

* Description
  - The system to be installed is slackware 14.2 64bits, although some script
    might help to keep it updated
  - Services to be configured:
    - DHCP + DNS + MASQUERADING : Using dnsmasq
    - NAT : Through arno iptables firewall
    - NIS : For now ...
    - NFS
    - Optional : Backup
  - Server is assumed to have two nics, one external (=eth0=), one
    internal (=eth1=)
  - The internal network of class C will use the segment 192.168.10.0/24

* Slackware installation
  Just download it from the official slackware web page. Get the dvd
  version. Install everything. It is advisable to have at least four
  partitions: one for root, one for swap, one for home, and one for tmp.
  
  Then use the configuration script on ~../configurations~ to config
  the slackware machine. 

* Configuration of client and server for a computer room
** Parameters to configure bootstrap script
   #+begin_src sh :exports code :tangle scripts/EXAMPLE_params.conf
BASE_SERVERIP=192.168 
SERVERIP=${BASE_SERVERIP}.10.1
NISDOMAIN=salafisnis
SERVER_DOMAINNAME=serversalafis
FORCE=0 # Force rewrite of all config even if it is already configured

## Proxy stuff : removed auth info since I will be using a cntlm config on the server
# UNAL
#PROXY=fisicasop_fcbog:PASSWD@proxyapp.unal.edu.co:8080
# local cntlm config running on server
PROXY=${SERVERIP}:3128
   #+end_src
** Configuring root internet behind proxy unal
   #+NAME: proxy_config
   #+BEGIN_SRC bash :exports code 
     # Configure root internet access
     MSG="Configuring proxy for root"
     start_msg "$MSG"
     bname="/root/.bashrc"
     if [ x"" == x"$(grep https_proxy ${bname})" ] || [ $FORCE -eq 1 ] ; then
	 touch $bname
	 backup_file $bname
	 cat <<EOF > $bname
	 export PROXY="$PROXY"
	 export http_proxy="http://\$PROXY"
	 export https_proxy="http://\$PROXY" 
	 export ftp_proxy="ftp://\$PROXY"
	 export RSYNC_PROXY="\$PROXY" 
     EOF
     else
	 echo "#    -> already configured."
     fi
     source /root/.bashrc
     end_msg "$MSG"

   #+END_SRC
** [Deprecated] Installing sbopkg                                  :noexport:
   #+NAME: sbopkg_config
   #+BEGIN_SRC bash :exports code 
MSG="Installing sbopkg"
echo "$MSG"
installpkg "$FDIR/sbopkg-0.38.1-noarch-1_wsr.tgz"
echo "DONE: $MSG"
   #+END_SRC

** [Deprecated] Install slpkg : Moved to slackware config.         :noexport:
** [Deprecated] Moved to slackware config: Fix dhcpcd client (advertise mac address instead of ipv6 stuff)  
** Fix xinitrc
   #+NAME: xinitrc_config
   #+BEGIN_SRC bash :exports code
MSG="Fixing xinitrc on /etc/skel"
start_msg "$MSG"
if [ ! -f /etc/skel/.xinitrc ] || [[ $FORCE -eq 1 ]]; then 
    cp -f /etc/xdg/xfce4/xinitrc /etc/skel/.xinitrc
    chmod +x /etc/skel/.xinitrc
else
    echo "#    -> Already fixed"
fi
end_msg "$MSG"
MSG="Fixing xsession on /etc/skel"
start_msg "$MSG"
if [ ! -f /etc/skel/.xsession ] || [[ $FORCE -eq 1 ]]; then 
    cp -f /etc/xdg/xfce4/xinitrc /etc/skel/.xsession
else
    echo "#   -> Already fixed"
fi
end_msg "$MSG"

   #+END_SRC
** Latam keyboard
   #+name:latam_keyboard
   #+begin_src sh
# latam keyboard
MSG="Configuring default X windows keyboard to be latam ..."
start_msg "$MSG"
bfile=/etc/X11/xorg.conf.d/90-keyboard-layout.conf
#if [ $(pattern_not_present "latam" "$bfile") ]; then 
if [ x"" == x"$(grep latam ${bfile} 2>/dev/null)" ] || [ $FORCE -eq 1 ] ; then
    if [ -f $bfile ]; then
	backup_file $bfile
    fi
    cat<<EOF > $bfile
Section "InputClass"
        Identifier "keyboard-all"
        MatchIsKeyboard "on"
        MatchDevicePath "/dev/input/event*"
        Driver "evdev"
        Option "XkbLayout" "latam"
        #Option "XkbVariant" ""
        Option "XkbOptions" "terminate:ctrl_alt_bksp"
EndSection
EOF
else
    echo "#    -> already configured"
fi
end_msg "$MSG"

   #+end_src
** Configure Network interfaces
   #+name: nic_config
   #+BEGIN_SRC bash :exports code 
# network interfaces
MSG="Configuring network interfaces "
start_msg "$MSG"
if [ "$TARGET" == "SERVER" ]; then
    #if [ $(pattern_not_present "127.0.0.1" "/etc/resolv.conf.head") ]; then
    if [ x"" == x"$(grep 127.0.0.1 /etc/resolv.conf.head)" ] || [ $FORCE -eq 1 ] ; then
	echo "Setting up resolv.conf.head "
	TFILE="/etc/resolv.conf.head"
	copy_config "$FDIR/SERVER-etc-resolv.conf.head" "$TFILE"
    fi	
    #if [ $(pattern_not_present "$SERVERIP" "/etc/rc.d/rc.inet1.conf") ]; then 
    if [ x"" == x"$(grep $SERVERIP /etc/rc.d/rc/inet1.conf)" ] || [ $FORCE -eq 1 ] ; then
	bash /etc/rc.d/rc.networkmanager stop
	chmod -x /etc/rc.d/rc.networkmanager
	copy_config "$FDIR/SERVER-etc-rc.d-rc.inet1.conf" /etc/rc.d/rc.inet1.conf
    else
	echo "Already configured, just restarting services ..."
    fi
    /etc/rc.d/rc.inet1 restart
else
    echo "# Creating Network Manager hook"
    if [ ! -f "/etc/NetworkManager/dispatcher.d/90networkmanagerhook.sh" ] || [ $FORCE -eq 1 ]; then
	cp $FDIR/CLIENT-90networkmanagerhook.sh /etc/NetworkManager/dispatcher.d/90networkmanagerhook.sh
	chmod +x /etc/rc.d/rc.networkmanager
	bash /etc/rc.d/rc.networkmanager restart
	/etc/rc.d/rc.inet2 restart
    else
	echo "#    -> already configured."
    fi
fi
end_msg "DONE: $MSG"
   #+END_SRC

** Client ntp
   #+name:ntp_config
   #+begin_src sh 
# ntp server
if [ "$TARGET" == "CLIENT" ]; then
    MSG="Configuring ntp "
    start_msg "$MSG"
    #if [ $(pattern_not_present "$SERVERIP" "/etc/ntp.conf") ]; then
    if [ x"" == x"$(grep $SERVERIP /etc/ntp.conf)" ] || [ $FORCE -eq 1 ] ; then
        echo "STATUS -> $(pattern_not_present "$SERVERIP" "/etc/ntp.conf")"
	bfile=/etc/ntp.conf
	backup_file $bfile
	cp -f $FDIR/CLIENT-ntp-client.conf $bfile
	chmod +x /etc/rc.d/rc.ntpd
	/etc/rc.d/rc.ntpd restart
    else
	    echo "#    -> already configured"
    fi
    end_msg "$MSG"
fi

   #+end_src

** dnsmasq : dhcp, dns, masquerading
   #+name: dnsmasq_config
   #+BEGIN_SRC bash :exports code 
# dnsmasq
MSG="Configuring dnsmasq "
if [ "$TARGET" == "SERVER" ]; then
    start_msg "$MGS"
    TFILE="/etc/dnsmasq.conf"
    if [ ! -f $TFILE ] || [ $FORCE -eq 1 ]; then  
	copy_config "$FDIR/SERVER-etc-dnsmasq.conf" "$TFILE"
	TFILE="/etc/dnsmasq-hosts.conf"
	copy_config "$FDIR/SERVER-etc-dnsmasq-hosts.conf" "$TFILE"
	chmod +x /etc/rc.d/rc.dnsmasq 
	TFILE="/etc/hosts"
	copy_config "$FDIR/SERVER-etc-hosts" "$TFILE"
    else
	echo "Already configured. Restarting services ..."
    fi
    /etc/rc.d/rc.dnsmasq restart
    end_msg "DONE: $MSG"
fi

   #+END_SRC

** Firewall ( also for NAT) : Arno iptables firewall.
   I will use arno iptables firewall because it has worked pretty well
   before . It must be installed before this step. If not installed , I
   will try to use slpkg to install it.

   #+NAME: firewall_config
   #+BEGIN_SRC bash :exports code
# firewall 
MSG="Configuring firewall "
if [ "$TARGET" == "SERVER" ]; then
    start_msg "$MSG"
    if $(command_exists arno-iptables-firewall) && [[ $FORCE -eq 0 ]]; then
	echo "    -> firewall already installed and configured."
    else
	#sbopkg -e stop -B -k -i arno-iptables-firewall
	source /root/.bashrc
	slpkg upgrade
	#slpkg -s sbo arno-iptables-firewall-2.0.1e-noarch-3_SBo
	slpkg -s sbo arno-iptables-firewall
	ln -svf /etc/rc.d/rc.arno-iptables-firewall /etc/rc.d/rc.firewall
	copy_config "$FDIR/SERVER-firewall.conf" "/etc/arno-iptables-firewall/firewall.conf"
	chmod o-rwx /etc/arno-iptables-firewall/firewall.conf
	chmod +x /etc/rc.d/rc.arno-iptables-firewall
    fi
    /etc/rc.d/rc.firewall restart
    end_msg "$MSG"
fi
# read
   #+END_SRC
** [Deprecated] kanif cluster tools                                :noexport:
   #+NAME: kanif_config
   #+BEGIN_SRC bash :exports code 
# kanif cluster tools
#echo "Configuring kanif "
#ssh-keygen -t rsa
#for a in ssf6 ssf7 ssf8 ssf9; do
#    yes 'PASSWORD' | ssh-copy-id -i ~/.ssh/id_rsa.pub $q
#done
# if [ "$TARGET" == "SERVER" ]; then
#     echo "Kanif assumed to be installed in slackware."
# fi
# copy_config "$FDIR/SERVER-etc-c3.conf" "/etc/kanif.conf"
# #kash ls
# echo "DONE: Configuring kanif "
# # read

   #+END_SRC
** NFS
   #+NAME: nfs_config
   #+BEGIN_SRC bash :exports code 
# nfs
MSG="Configuring nfs "
start_msg "$MSG"
if [ "$TARGET" == "SERVER" ]; then
    #if [ $(pattern_not_present "$BASE_SERVERIP" "/etc/hosts.allow") ]; then
    if [ x"" == x"$(grep $BASE_SERVERIP /etc/hosts.allow)" ] || [ $FORCE -eq 1 ] ; then
	copy_config "$FDIR/SERVER-etc-hosts.allow" "/etc/hosts.allow"
    else
        echo "hosts allow already configured"
    fi
    #if [ $(pattern_not_present "$SERVERIP" "/etc/exports") ]; then
    if [ x"" == x"$(grep $SERVERIP /etc/exports)" ] || [ $FORCE -eq 1 ] ; then
	copy_config "$FDIR/SERVER-etc-exports" "/etc/exports"
    else
	echo "Exports already configured. Restarting services ..."
    fi
    chmod +x /etc/rc.d/rc.nfsd 
    /etc/rc.d/rc.nfsd restart
    /etc/rc.d/rc.inet2 restart
    echo "NOTE: If you have NFS problems, consider editing the /etc/hosts.allow and /etc/hosts.deny files"
else
    bfile="/etc/fstab"
    #if [ $(pattern_not_present "${SERVERIP}" "$bfile") ]; then
    if [ x"" == x"$(grep ${SERVERIP} ${bfile})" ] || [ $FORCE -eq 1 ] ; then
	backup_file $bfile
	echo "# NEW NEW NEW NFS stuff " >> $bfile
	echo "${SERVERIP}:/home     /home   nfs     rw,hard,intr,usrquota  0   0" >> $bfile
    else
	echo "#    -> already configured"
    fi
fi
end_msg "$MSG"

   #+END_SRC
** NIS
   #+NAME: nis_config
   #+BEGIN_SRC bash :exports code
     # nis
     MSG="Configuring nis "
     start_msg "$MSG"
     chmod +x /etc/rc.d/rc.yp
     if [ "$TARGET" == "SERVER" ]; then
         #if [ $(pattern_not_present "${NISDOMAIN}" "/etc/defaultdomain") ] ; then 
	 if [ x"" == x"$(grep $NISDOMAIN /etc/defaultdomain)" ] || [ $FORCE -eq 1 ] ; then
             copy_config "$FDIR/SERVER-etc-defaultdomain" "/etc/defaultdomain"
         else
             echo "Already configured default nis domain"
         fi
         #if [ $(pattern_not_present "${NISDOMAIN}" "/etc/yp.conf") ] ; then 
	 if [ x"" == x"$(grep $NISDOMAIN /etc/yp.conf)" ] || [ $FORCE -eq 1 ] ; then
             copy_config "$FDIR/SERVER-etc-yp.conf" "/etc/yp.conf"
             copy_config "$FDIR/SERVER-var-yp-Makefile" "/var/yp/Makefile"
         else
             echo "Already configured yp"
         fi

         backup_file /etc/rc.d/rc.yp
         if [ x"" == x"$(grep 'YP_SERVER_ENABLE=1' /etc/rc.d/rc.yp 2>/dev/null)"]; then 
             sed -i.bck 's/YP_CLIENT_ENABLE=.*/YP_CLIENT_ENABLE=0/ ; s/YP_SERVER_ENABLE=.*/YP_SERVER_ENABLE=1/ ;' /etc/rc.d/rc.yp
         else
             echo "Already configured as yp server"
         fi
    
         echo "Running nis services ..."
         ypserv
         make -BC /var/yp
         #/usr/lib64/yp/ypinit -m
     else
         chmod +x /etc/rc.d/rc.nfsd
         #if [ $(pattern_not_present "${NISDOMAIN}" "/etc/defaultdomain") ]; then
	 if [ x"" == x"$(grep $NISDOMAIN /etc/defaultdomain)" ] || [ $FORCE -eq 1 ] ; then
             bfile="/etc/defaultdomain"
             backup_file $bfile
             echo ${NISDOMAIN} > $bfile  
	     bfile="/etc/rc.d/rc.local"
	     backup_file $bfile
	     echo 'nisdomainname -F /etc/defaultdomain' > $bfile
             bfile="/etc/yp.conf"
             backup_file $bfile
             echo "ypserver ${SERVERIP}" > $bfile
             bfile=/etc/nsswitch.conf
             backup_file $bfile
             cp -f $FDIR/CLIENT-nsswitch.conf $bfile
             bfile="/etc/passwd"
             backup_file $bfile
             echo +:::::: >> $bfile
             bfile="/etc/shadow"
             backup_file $bfile
             echo +:::::::: >> $bfile
             bfile="/etc/group"
             backup_file $bfile
             echo +::: >> $bfile
             if [ x"" == x"$(grep 'YP_CLIENT_ENABLE=1' /etc/rc.d/rc.yp) 2>/dev/null" ]; then 
                 backup_file /etc/rc.d/rc.yp
                 sed -i.bck 's/YP_CLIENT_ENABLE=.*/YP_CLIENT_ENABLE=1/ ; s/YP_SERVER_ENABLE=.*/YP_SERVER_ENABLE=0/ ;' /etc/rc.d/rc.yp
             fi
         else
             echo "#    -> already configured."
         fi
     fi
     nisdomainname -F /etc/defaultdomain
     end_msg "$MSG"

     #+END_SRC
** Client: Copy public id for password-less access and allow root login
   #+name:publicid_config
   #+begin_src sh 
if [ "$TARGET" == "CLIENT" ]; then 
    MSG="Copying server public key  to configure passwordless access for root"
    start_msg "$MSG"
    mkdir -p /root/.ssh &>/dev/null
    #if [ $(pattern_not_present "${SERVER_DOMAINNAME}" "/root/.ssh/authorized_keys") ]; then
    if [ x"" == x"$(grep $SERVER_DOMAINNAME /root/.ssh/authorized_keys)" ] || [ $FORCE -eq 1 ] ; then
	cat $FDIR/CLIENT-server_id_rsa.pub >> /root/.ssh/authorized_keys
	chmod 700 /root/.ssh
	chmod 640 /root/.ssh/authorized_keys
    else
	echo "#    -> already configured"
    fi
    end_msg "$MSG"
    
    MSG="Allowing root login for client"
    start_msg "$MSG"
    bfile="/etc/ssh/sshd_config"
    if [ x"" == x"$(grep '^PermitRootLogin.*yes' $bfile)" ] || [ $FORCE -eq 1 ] ; then
	backup_file $bfile
	echo "PermitRootLogin yes" >> $bfile
	/etc/rc.d/rc.sshd restart
    else
	echo "#    -> already_configured"
    fi
    end_msg "$MSG"
fi

   #+end_src
** TODO Remove permissions to halt/shutdown from button and gui (todo)
   #+name:shutdown_config
   #+begin_src sh
MSG="Removing permissions to reboot/halt system"
start_msg "$MSG"
fname=disallow-power-options.rules
if [ ! -f /etc/polkit-1/rules.d/$fname ] || [ $FORCE -eq 1 ]; then
    chmod o-x /sbin/shutdown 
    chmod o-x /sbin/halt
    cp $FDIR/$fname /etc/polkit-1/rules.d/
else
    echo "#    -> polkit rules lready configured"
fi

tfname=/etc/acpi/acpi_handler.sh
#if [ $(pattern_not_present "emoves" "$tfname") ]; then
if [ x"" == x"$(grep emoves ${tfname})" ] || [ $FORCE -eq 1 ] ; then
    copy_config $FDIR/etc-acpi-acpi_handler.sh $tfname
else
    echo "#   -> Acpi handler already configured"
fi

end_msg "$MSG"

   #+end_src
** Packages on client/server
   Crontab will check, every hour, for two options
    1. *Recommended*: It will use ~slpkg~ to install all packages
       specified inside the file ~/home/PACKAGES.list~ . This will
       compile everything on each client, taking more time on the
       slowest, but will make sure that all clients will conform with
       their own installed libs.
    2. *Alternative, not recommended* It will install the contents
       inside the folder ~/home/PACKAGES/~ . It is assumed that home
       is exported on NFS, so all clients will see that file. Packages
       inside that folder might require dependencies also to be inside
       that folder. This is useful if one setups a package building
       server and then copy all the packages inside the named folder,
       but this assumes that all clients have the same libs installed,
       so it depends on the homogeneity of the clients.
** Crontab
   This crontab reads a given script and runs it every some time
   #+name:crontab_config
   #+begin_src sh :exports code 
MSG="Configuring crontab per minute, hour, daily, etc"
start_msg "$MSG"
crontab -l > /tmp/crontab
if [ "$TARGET" == "SERVER" ]; then
    if [ x"" == x"$(grep minute_maintenance.sh /etc/crontab)" ] || [ $FORCE -eq 1 ] ; then
	crontab $FDIR/SERVER-crontab -u root
    else
	echo "#    -> Already configured (per minute)"
    fi
    TNAME="/etc/cron.daily/daily_maintenance.sh"
    if [ ! -f $TNAME ] || [ $FORCE -eq 1 ]; then
        copy_config $FDIR/SERVER-cron/daily_maintenance.sh "$TNAME"
    else
        echo "#    -> Already configured (daily)"
    fi
else # CLIENT
    if [ x"" == x"$(grep check_status.sh /tmp/crontab)" ] || [ $FORCE -eq 1 ] ; then
	crontab $FDIR/CLIENT-crontab -u root
    else
	echo "#    -> Already configured"
    fi
fi
end_msg "$MSG"

   #+end_src
** PACKAGES
   This uses the ~/home/PACKAGES.list~ approach read by the weekly
   cronjob to install the needed packages. Of course, it can be run
   when sooner, when needed.
   #+begin_src shell
MSG="Creating package list"
start_msg "$MSG"
if [ "TARGET" == "SERVER" ]; then
    if [ ! -f /home/PACKAGES.list ]; then
	cat << EOF > /home/PACKAGES.list
bonnie++ arno-iptables-firewall iotop wol squid tor  autossh  parallel sshfs-fuse xfce4-xkb-plugin
dropbox ffmpeg syncthing
ganglia ganglia-web glusterfs rrdtool papi openmpi hdf5 
octave qtoctave codeblocks geany kdiff3 kile 
R grads rstudio-desktop cdo 
obs-studio ssr asciinema 
EOF
    fi
fi
end_msg "$MSG"
   #+end_src
** ONGOING Install and configure monit 
   Monit is a tool that allows to monitor and restart if needed
   different services, files, etc. This will be another level of
   redundancy (besides the scripts in crontab) to keep services
   running. TODO: configure essential services on server and clients. 
   #+name:monit_config
   #+begin_src sh :exports code
MSG="Configuring monit on server "
start_msg "$MSG"
if [ "$TARGET" == "SERVER" ]; then 
    if $(command_exists monit) && [[ $FORCE -eq 0 ]]; then
	echo "#    -> already installed"
    else
	source /root/.bashrc
	slpkg -s sbo monit
	chmod +x /etc/rc.d/rc.monit 
	backup_file /root/.monitrc
	copy_config "$FDIR/SERVER-root-dotmonitrc" "/root/.monitrc"
	backup_file /etc/rc.d/rc.local
	echo "/usr/bin/monit -c /root/.monitrc &> /var/log/log-monit-root&" >> /etc/rc.d/rc.local
	/etc/rc.d/rc.monit restart
    fi
else
    echo "Not configuring on client (for now)."
fi
end_msg "$MSG"

   #+end_src
** cntlm 
   This allows to create a bypassing pry that handles all auth and
   allows for computers to use  a simple proxy with no auth. For
   instance, with this I can now use emacs and install packages
   without much hassle. 
   #+name:cntlm_config
   #+begin_src sh :exports code
MSG="Configuring cntlm on server "
start_msg "$MSG"
if [ "$TARGET" == "$SERVER" ]; then 
    if $(command_exists cntlm) && [[ $FORCE -eq 0 ]]; then
	echo "#    -> already installed"
    else
	source /root/.bashrc
	slpkg -s sbo cntlm
	chmod +x /etc/rc.d/rc.cntlm 
	backup_file /etc/cntlm.conf
	copy_config "$FDIR/SERVER-etc-cntlm.conf" "/etc/cntlm.conf"
	echo "Please write the password for the account to be used with cntlm"
	cntlm -H > /tmp/cntlm-hashed
	cat /tmp/cntlm-hashed >> /etc/cntlm.conf
	rm -f /tmp/cntlm-hashed
	/etc/rc.d/rc.cntlm restart
    fi
else
    echo "Not configuring on client."
fi
end_msg "$MSG"

   #+end_src
** TODO Install and configure slim
   #+name:slim_config
   #+begin_src sh :exports code
MSG="Installing and configuring slim "
start_msg "$MSG"
if $(command_exists slim) && [[ $FORCE -eq 0 ]]; then
    echo "#    -> already installed"
else
    source /root/.bashrc
    slpkg -s sbo slim
    chmod +x /etc/rc.d/rc.cntlm 
    backup_file /etc/cntlm.conf
    copy_config "$FDIR/SERVER-etc-cntlm.conf" "/etc/cntlm.conf"
    echo "Please write the password for the account to be used with cntlm"
    cntlm -H > /tmp/cntlm-hashed
    cat /tmp/cntlm-hashed >> /etc/cntlm.conf
    rm -f /tmp/cntlm-hashed
    /etc/rc.d/rc.cntlm restart
fi
end_msg "$MSG"

   #+end_src
   
** Write final script
   #+BEGIN_SRC bash :exports code :noweb yes :tangle scripts/EXAMPLE-00-bootstrap_slackware.sh :tangle-mode (identity #o444) 
#!/bin/bash

# NOTE: The original base file is in the config_computer_room.org file

SCRIPTS_DIR=$HOME/repos/computer-labs/computer-room/scripts

if [ ! -f params.conf ]; then 
    echo "ERROR: Config file not found -> params.conf"
    exit 1
fi
source params.conf
source $SCRIPTS_DIR/util_functions.sh

# check args
if [ "$#" -ne "2" ]; then usage; exit 1 ; fi
if [ ! -d "$1" ]; then echo "Dir does not exist : $1"; usage; exit 1 ; fi
if [  "$2" != "SERVER" ] && [ "$2" != "CLIENT" ]; then usage; exit 1 ; fi

TARGET="$2"
# global vars
BDIR=$PWD
FDIR=$1
LINUX="SLACKWARE"

echo "###############################################"
echo "# Configuring $TARGET ..."
if [[ $FORCE -eq 1 ]]; then 
    echo "# Forcing configuration ..."; 
fi
echo "###############################################"

<<proxy_config>>

<<dhcpcd_config>>

<<nic_config>>

<<xinitrc_config>>

<<latam_keyboard>>

<<ntp_config>>

<<dnsmasq_config>>

<<firewall_config>>

<<nfs_config>>

<<nis_config>>

<<monit_config>>

<<publicid_config>>

<<shutdown_config>>

<<crontab_config>>

<<cntlm_config>>

# run services (better done on script that keeps the system up, when the client is on the network)
#/etc/rc.d/rc.nfsd restart
#mount -a 
#/etc/rc.d/rc.yp restart    
#/etc/rc.d/rc.inet2 restart
#rpcinfo -p localhost


   #+END_SRC

** TODO pssh?
   - https://unix.stackexchange.com/questions/128974/parallel-ssh-with-passphrase-protected-ssh-key
   - https://www.funtoo.org/Keychain
   - https://stackoverflow.com/questions/43597283/pass-the-password-as-an-argument-in-pssh
   - https://www.golinuxcloud.com/pssh-public-key-authentication-passwordless/

* Auxiliary scripts
** Create an user
  #+BEGIN_SRC sh :exports code :mkdirp yes :tangle scripts/create_user.sh 
     #!/bin/bash                                                                                                               
     if [ x"" != x"$1" ]; then
	 adduser $1
	 usermod -a -G audio,cdrom,floppy,plugdev,video,power,netdev,lp,scanner $1
	 make -BC /var/yp
	 #su - $1                                                                                                              
	 #xwmconfig                                                                                                            
     else
	 echo "Error. Debes llamar este script como:"
	 echo "bash $0 nombredeusuarionuevo"
     fi

  #+END_SRC
   
** Check and delete inactive users
   - Find inactive users
     #+BEGIN_SRC sh :exports code :tangle scripts/get_inactive.sh
DAYS=180
OFILE=/root/inactive_users.txt
echo > $OFILE
for dname in /home/*; do 
    if [ -d $dname ]; then 
	result=$(find "${dname}" -mtime -${DAYS} -type f -print -quit)
	if [[ $result == "" ]]; then
	    echo "User home has been inactive for more than ${DAYS} days : $dname"
	    echo "${dname#/home/}" >> $OFILE
	fi
    fi
done
echo "###########################################"
echo "Inactive users wrote to $OFILE"
      
     #+END_SRC
   - Delete inactive users
     #+BEGIN_SRC  sh :exports code :tangle scripts/del_inactive.sh
for a in $(cat /root/inactive_users.txt); do
    if [ "$a" == "ramezquitao" ] || [ "$a" == "ersanchezp" ] || [ "$a" == "jdmunozc" ] || [ "$a" == "jbaena" ] || [ "$a" == "oquendo" ]; then
        echo "skipping account : $a"
        continue
    fi
    echo "deleting $a"
    userdel -rf $a;
done
     #+END_SRC
** User disk usage
   #+BEGIN_SRC sh :exports code :mkdirp yes :tangle scripts/user_disk_usage.sh
      echo "Computing user disk usage ... "
      for a in /home/*; do 
	  du -sh $a ; 
      done | sort -rh > user_disk_usage.txt
      echo "################################"
      echo "DONE: results sorted and wrote to user_disk_usage.txt"

   #+END_SRC
** Create users from csv list with usernames and ids
   This script reads a list of usernames and passwords and creates the
   corresponding users
   #+begin_src sh :exports code :tangle scripts/create_users_from_list.sh :tangle-mode (identity #o444)
#!/bin/bash

FNAME=${1}
if [[ ! -f $FNAME ]]; then
    echo "Error: filename $FNAME does not exists"
    exit 1
fi

while read line
do
    username=$(echo $line | awk '{print $1}')
    password=$(echo $line | awk '{print $2}')
    echo username=$username
    echo password=$password
    # echo "Deleting account $username"
    # userdel $username
    echo Creating account $username
    useradd -d /home/$username -G audio,cdrom,floppy,plugdev,video -m -s /bin/bash $username 
    echo "Changing password for $username to ${password}"
    echo ${username}:${password} | chpasswd
    #echo "Recursive chown ... &"
    #chown -R $username.$username /home/$username &
done < $FNAME

read

echo "Updating nis database"
make -C /var/yp/
service portmap restart
service ypserv  restart
echo "DONE."

   #+end_src
** Recreate users from folders inside home 
   This is useful when the server was reinstalled
   #+begin_src sh :exports code :tangle scripts/recreate_users_from_directories.sh :tangle-mode (identity #o444)
#!/bin/bash

for usernamedir in /home/*; do 
    if [ -d $usernamedir ]; then
	username=$(basename $usernamedir)
	if [ "ftp" != "$username" ] && [ "localuser" != "$username" ] ; then 
	    #echo "Deleting account $username"
	    #userdel $username
	    echo Creating account $username
	    useradd -d /home/$username -G audio,cdrom,floppy,plugdev,video -m -s /bin/bash $username
	    echo "Changing password for $username to ${username}123"
	    echo ${username}:${username}123 | chpasswd 
	    echo "Recursive chown ... &"
	    chown -R $username.$username /home/$username & 
	fi
    fi
done
echo "Updating nis database"
make -C /var/yp/
service portmap restart
service ypserv  restart

echo "DONE."

   #+end_src
** Data dir for users
   In case there are some hard disk space to share between users,
   create directories for each one
   #+begin_src sh  :exports code :tangle scripts/create_data_dirs_for_users.sh :tangle-mode (identity #o444)
#!/bin/bash

for a in /home/*; do
    bname=$(basename $a)
    id -u $bname &> /dev/null
    status=$?
    #echo $bname
    #echo $status
    if [[ "0" -eq "$status" ]]; then
	for b in data01 data02; do
	    mkdir -p /mnt/local/$b/$bname	    
	    chown -R $bname.$bname /mnt/local/$b/$bname
	done
    fi
done
   #+end_src

** Burn slackware live
  - live
    #+BEGIN_SRC sh :tangle scripts/burn_slackware_live.sh
USBKEYS=($(
    grep -Hv ^0$ /sys/block/*/removable |
    sed s/removable:.*$/device\\/uevent/ |
    xargs grep -H ^DRIVER=sd |
    sed s/device.uevent.*$/size/ |
    xargs grep -Hv ^0$ |
    cut -d / -f 4
))

echo "Burning slackware image iso to /dev/sd{b,c,d,e,f,g,h} -> ${USBKEYS[*]}"
parallel --gnu "dd if=/root/dev-iso/slackware64-live-current.iso of=/dev/{} " ::: ${USBKEYS[*]}
if [ "$?" == "0" ]; then
    sync
    echo "Done. Please test the usb on another computer"
else
    echo "Some error ocurred. Exiting."
fi
    #+END_SRC
  - With persistence
    #+BEGIN_SRC sh :tangle scripts/burn_slackware_live_persistence.sh
USBKEYS=($(
    grep -Hv ^0$ /sys/block/*/removable |
    sed s/removable:.*$/device\\/uevent/ |
    xargs grep -H ^DRIVER=sd |
    sed s/device.uevent.*$/size/ |
    xargs grep -Hv ^0$ |
    cut -d / -f 4
))
echo "Burning slackware image iso with persistence to /dev/sd{b,c,d,e,f,g,h} -> ${USBKEYS[*]}"
#parallel --gnu bash /root/dev-iso/liveslak/iso2usb.sh -i /root/dev-iso/slackware64-live-current.iso -o /dev/{} -u -v -w 30  ::: ${USBKEYS[*]}
bash /root/dev-iso/liveslak/iso2usb.sh -i /root/dev-iso/slackware64-live-current.iso -o /dev/${USBKEYS[0]} -u -v -w 30
if [ "$?" == "0" ]; then
    echo "Done. SYncing writing ... "
    sync
    echo "Done. Please test the usb on another computer"
else
    echo "Some error ocurred. Exiting."
fi
    #+END_SRC
** Peformance monitor
  #+BEGIN_SRC sh :exports code :tangle scripts/monitor_perf.sh
    TOTALITER=10800
    iotop -botq --iter=$TOTALITER &>> /tmp/log-iotop
    top -b -n $TOTALITER &>> /tmp/log-top
    /usr/local/sbin/iftop -P -b -i eth0 -t &>> /tmp/log-iftop-eth0
    /usr/local/sbin/iftop -P -b -i eth0 -t &>> /tmp/log-iftop-eth1

    vmstat -a -t 1 $TOTALITER &>> /tmp/log-vmstat
    vmstat -s -t 1 $TOTALITER &>> /tmp/log-vmstat-s
    vmstat -D -t 1 $TOTALITER &>> /tmp/log-vmstat-D

    function runiostat {
	while  [ 1 ]; do
	    sleep 1
	    iostat >> /tmp/log-iostat
    }

    runiostat
  #+END_SRC

* Problems and solutions [6/6]
** DONE Solving problems with xinit and xfce for all and new users
   CLOSED: [2020-02-29 Sat 19:27]
   - Make sure all users are on the video group. Maybe run
     #+BEGIN_SRC bash
     usermod -a -G audio,cdrom,floppy,plugdev,video,power,netdev,lp,scanner USERNAME
     #+END_SRC
     on each user.
   - Make sure that the minimum gid in yp nis is 2 (see file
     =/var/yp/Makefile=)

** DONE Dhcpcd                                                    :SLACKWARE:
   CLOSED: [2019-10-16 Wed 10:25]
   The latest slackware version advertises the nic using a new
   identity called iuad or something but the dhcp server at unal does
   not read it so I needed to edit the /etc/dhcpcd.conf file and
   activate sending the hardware address
** DONE Advertising Ethernet speeds for eth1
   CLOSED: [2019-10-16 Wed 10:25]
   (SLackware does not have this problem)
  The connection from/to server through eth1 was at a maximum of
  10MB/s. while the interface supported gigabit. After many tests I
  found that by using the command
  #+begin_src shell
  ethtool -s eth1 advertise 0x010
  #+end_src
  I was able to advertise up to gigabit and then run at 100MB/s, which
  is the least acceptable given the router.

  For slackware I added this to the minute_maintenance.sh . 

  To make this command permanent in debian, I had to add the following
  line under the config for ~eth1~ in the file
  ~/etc/network/interfaces~
  #+begin_src shell 
  post-up /sbin/ethtool -s eth1 advertise 0x010
  #+end_src
** Setup dropbox
  #+begin_src sh
   ~/miniconda3/bin/python ~/dropbox.py proxy manual http proxyapp.unal.edu.co 8080 USERNAME PASSWORD
  #+end_src
** Instalando paquetes en R desde una cuenta de usuario
  Para instalar paquetes desde una cuenta de usuario se usa el comando
  normal ~install.packages~ . Pero si se hace desde un computador de
  la universidad, es necesario configurar el proxy antes de entrar a
  ~R~. 
  
  *Nota*: Una vez instalados los paquetes no es necesario volver a
   instalarlos, pero cada usuario debe instalar sus paquetes en su
   cuenta. 

*** Configuración del proxy
   Existen dos formas de hacerlo. La primera, es la mas sencilla pero
   debe hacerse cada vez que se abra una consola nueva. Esta primera
   forma consiste en exportar las variables del proxy de la siguiente
   manera
   #+BEGIN_SRC sh :exports code
export http_proxy="http://USERNAME:PASSWORD@proxyapp.unal.edu.co:8080/"
export https_proxy="https://USERNAME:PASSWORD@proxyapp.unal.edu.co:8080/"
export ftp_proxy="http://USERNAME:PASSWORD@proxyapp.unal.edu.co:8080/"
   #+END_SRC
   en donde se debe reemplazar =USERNAME= por el nombre del usuario
   (de la universidad, sin incluir @unal.edu.co) y =PASSWORD= es el password de
   la universidad. En adelante podrá navegar por la consola. Se se
   desea que estos comandos siempre se ejecuten al abrir una consola,
   se pueden copiar al final del archivo =~/.ḃashrc= .

   La segunda forma consiste en añadir el proxy a la información del
   profile de =R=. Para esto, debe abrir el archivo oculto
   =~.Renviron= (se puede abrir desde el mismo =R= usando el comando
   =file.edit('~˙Renviron')=, y escribir allí
   #+BEGIN_SRC sh
http_proxy=http://USERNAME:PASSWORD@proxyapp.unal.edu.co:8080/
http_proxy_user=USERNAME:PASSWORD

https_proxy=https://USERNAME:PASSWORD@proxyapp.unal.edu.co:8080/
https_proxy_user=USERNAME:PASSWORD
   #+END_SRC
   con la convención ya explicada. Este archivo es leido por =R= y por
   =R studio=. En adelante, cada vez que se ejecute =R= se cargarán
   estas variables.

*** Instalación de paquetes
   En este caso simplemente se debe entrar a =R= y ejecutar el comando
   #+BEGIN_SRC sh
   install.packages(c("ggplot", "dplyr", "p", "rgeos", "digest", "foreign"), repos="https://www.icesi.edu.co/CRAN/")
   #+END_SRC
   Ese repositorio/mirror está ubicado en Colombia y es rápido, pero se puede
   usar cualquier otro.

   Los paquetes quedaran instalados en las cuentas locales de los
   usuarios. 
** Anaconda problems with qt
 If some error like "Cannot run ... QT ... xcb plugin ... " appears,
 maybe it needs to fix permissions. Run the following command:
 #+begin_src shell
  sudo chmod 755 /opt/anaconda2/bin/qt.conf
 #+end_src
** Formating usb (recovering the usb)
  Use gdisk
  #+begin_src sh
   gdisk
   enter recovery
   c
   e
   v
   w
   q
  #+end_src
  #+begin_src sh
   parted /dev/sdb
   mklabel GPT # accept destroying everything
  #+end_src
  Also you can use =cgdisk=.

  To completely delete the fs signatures
  #+begin_src 
   wipefs --all --force /dev/sdb
  #+end_src
** DONE [OLD] Installation  and setup of gdb numpy
   CLOSED: [2019-10-16 Wed 10:30]
  Anaconda creates a lot of problems. It is necessary to clean the path. The command I used was:
  #+begin_src shell
  kash ". ~/.bashrc; . /home/oquendo/PATH.sh; installpkg /home/oquendo/Downloads/pip-9.0.1-x86_64-1_SBo.tgz; pip install matplotlib numpy; cd /home/oquendo/Escritorio/HerrComp/05-Debugging/gdb_numpy-1.0/; python setup.py install"
  #+end_src
  
** DONE [OLD] Armadillo problems with anaconda
   CLOSED: [2019-10-16 Wed 10:31]
  When installing armadillo, it finds the anaconda MKL and then a lot
  of problems arise when trying to run progrms with armadillo. This
  happens because putting anaconda bin on the path, in the first
  place, "overwrites" pkgconfig and many other system
  commands. Solution? eliminate anaconda from the path and then use
  alias or simething similar, like linking anaconda python, ipython,
  etc to /usr/local/bin, and no more.
** DONE [OLD] Anaconda problems with qt
   CLOSED: [2019-10-16 Wed 10:31]
  If some error like "Cannot run ... QT ... xcb plugin ... " appears,
  maybe it needs to fix permissions. Run the following command:
  #+begin_src shell
  sudo chmod 755 /opt/anaconda2/bin/qt.conf
  #+end_src
** [OLD] Ubuntu and related
*** Update git
   #+BEGIN_SRC sh
STATUS="$(grep -re wheezy-backports /etc/apt/sources.list | grep -v grep)"
if [ x"${STATUS}" == x ]; then
    echo "deb http://ftp.debian.org/debian wheezy-backports main" >> /etc/apt/sources.list
fi

apt-get update 

apt-get -t  wheezy-backports install "git" -y   
   #+END_SRC
  
** [OLD] Armadillo problems with anaconda
 When installing armadillo, it finds the anaconda MKL and then a lot
 of problems arise when trying to run progrms with armadillo. This
 happens because putting anaconda bin on the path, in the first
 place, "overwrites" pkgconfig and many other system
 commands. Solution? eliminate anaconda from the path and then use
 alias or simething similar, like linking anaconda python, ipython,
 etc to /usr/local/bin, and no more.

** [OLD] sbopkg behing firewall blocking rsync
   From : https://www.linuxquestions.org/questions/slackware-14/sbopkg-problem-774301/
   1. Download & install TOR from www.torproject.org
   2. Install polipo & torsocks
   3. Run "sudo torsocks sbopkg -r"
   4. Done, repository synced!

* PACKAGES
  This section is used to configure packages that have been already
  installed using the scripts inside the
  [[file:~/repos/computer-labs/packages/]] folder.  Hopefully every
  package will be installed using slpkg.

  - SlackBuild builder: https://alien.slackbook.org/AST/index.php
  - https://blog.spiralofhope.com/15906/slackware-package-managers.html
  - https://blog.spiralofhope.com/22995/checkinstall.html
  - slacktrack:
    https://www.reddit.com/r/slackware/comments/36flus/practices_for_package_maintenance_for_slackware/
  - src2pkg: https://distro.ibiblio.org/amigolinux/download/src2pkg/
  - https://idlemoor.github.io/slackrepo/links.html

** Spack
   - clone it
   - source env
   - Setup http proxy in .curlrc as proxy = http://user,,,,
   - bootstrap
   - resource env and add this to bashrc
   - Install whatever
   - load whatever with modeule load
   - make an example
** Ganglia
   [[http://ganglia.info/][Ganglia]] is a system used to monitor clusters. I will start using it
   to check the status of the computer room. The isnstallation is
   different for server and client. I will put both here. 
*** Server installation and configuration
    I need to install =rrdtool=, =ganglia= with gmetad activated, and
    =ganglia-web=. I will use slackbuilds although I cannot use sbopkg
    or similar since it does not work with the proxy.
    #+BEGIN_SRC bash :exports code :tangle scripts/ganglia-all-install-full.sh :tangle-mode (identity #o444)
# This scripts install ganglia and its requirements (rrdtool) on a server.
source ~/.bashrc
mkdir /tmp/ganglia
cd /tmp/ganglia

# Install rrdtool
if hash rrdtool &>/dev/null ; then
    echo "   Already installed"
else
    cd /tmp/ganglia
    echo "Downloading, compiling and installing rrdtool ..."
    wget -nc -c  http://oss.oetiker.ch/rrdtool/pub/rrdtool-1.7.0.tar.gz &&
	wget -nc -c https://slackbuilds.org/slackbuilds/14.2/libraries/rrdtool.tar.gz &&
	tar xf rrdtool.tar.gz &&
	cd rrdtool &&
	cp ../rrdtool-1.7.0.tar.gz ./ &&
	bash rrdtool.SlackBuild &&
	installpkg /tmp/rrdtool-1.7.0-x86_64-1_SBo.tgz &&
	echo "Done rrdtool. "
fi

# Install confuse
if [ ! -f /usr/lib64/libconfuse.la ]; then 
    cd /tmp/ganglia
    echo "Downloading, compiling and installing confuse ..."
    wget -nc -c  https://github.com/martinh/libconfuse/releases/download/v3.2/confuse-3.2.tar.gz &&
	wget -nc -c https://slackbuilds.org/slackbuilds/14.2/libraries/confuse.tar.gz &&
	tar xf confuse.tar.gz &&
	cd confuse &&
	cp ../confuse-3.2.tar.gz ./ &&
	bash confuse.SlackBuild &&
	installpkg /tmp/confuse-3.2-x86_64-1_SBo.tgz &&
	echo "Done lib confuse. "
fi

# install ganglia activating gmetad
if hash ganglia-config &>/dev/null ; then
    echo "    Already installed"
else
    cd /tmp/ganglia
    echo "Downloading, compiling and installing ganglia/gmetad ..."
    wget -nc -c  http://downloads.sourceforge.net/ganglia/ganglia-3.7.2.tar.gz &&
	wget -nc -c https://slackbuilds.org/slackbuilds/14.2/network/ganglia.tar.gz &&
	tar xf ganglia.tar.gz &&
	cd ganglia &&
	cp ../ganglia-3.7.2.tar.gz ./ &&
	OPT=gmetad ./ganglia.SlackBuild &&
	installpkg /tmp/ganglia-3.7.2-x86_64-1_SBo.tgz &&
	echo "Done ganglia/gmetad. "
fi

# install ganglia-web
if [ ! -d /var/www/htdocs/ganglia/ ]; then 
    cd /tmp/ganglia
    echo "Downloading, compiling and installing ganglia-web ..."
    wget -nc -c  http://downloads.sourceforge.net/ganglia/ganglia-web-3.7.2.tar.gz &&
	wget -nc -c https://slackbuilds.org/slackbuilds/14.2/network/ganglia-web.tar.gz &&
	tar xf ganglia-web.tar.gz &&
	cd ganglia-web &&
	cp ../ganglia-web-3.7.2.tar.gz ./ &&
	./ganglia-web.SlackBuild &&
	installpkg /tmp/ganglia-web-3.7.2-x86_64-1_SBo.tgz &&
	echo "Done ganglia-web. "
fi
    #+END_SRC

    And this is the configuration file
    #+BEGIN_SRC bash :exports code :tangle scripts/ganglia-server-config-gmetad.sh :tangle-mode (identity #o444)
# configure
if [ ! -f /etc/gmetad.conf ]; then
    echo "Configuring ganglia monitor gmetad..."
    cat <<EOF > /etc/gmetad.conf
# /etc/gmetad.conf on server
data_source "clustersalafis" $SERVER_DOMAINNAME
EOF
    echo "Done."
fi
    #+END_SRC
*** Client 
    The client can use the same server install script, but the
    configuration changes as follows
    #+BEGIN_SRC bash :exports code :tangle scripts/ganglia-client-config-gmond.sh :tangle-mode (identity #o444)
if [ ! -f /etc/gmond.conf ]; then 
    echo "Configuring gmond.conf ..."
    cat <<EOF > /etc/gmond.conf
#/etc/gmond.conf - on clustersalafis
cluster {
  name = "clustersalafis"
  owner = "unspecified"
  latlong = "unspecified"
  url = "unspecified"
}
 
udp_send_channel {
  mcast_join = $SERVERIP
  port = 8649
  ttl = 1
}
EOF
fi
echo "Done"
    #+END_SRC

** CDO [2019-09-18 Wed]
   Use alien AST
** GRADS [2019-09-18 Wed]
   Use alien AST
** Tortoisehg 2018
   Download the source code (and maybe use src2pkg) and install the
   package. See https://tortoisehg.bitbucket.io/download/source.html
** [OLD] Squid
  #+begin_src sh
   # only access from localhost is allowed
acl localhost src 127.0.0.1/32
acl all src all
http_access allow localhost
http_access deny all
icp_access deny all

never_direct allow all

# turn off cache
cache_dir null /tmp
cache deny all

# logs
access_log /var/log/squid/access.log squid

# turn off proxy-headers (no idea what is it :))
via off
forwarded_for off

# describe external proxy server
cache_peer 168.176.239.30 parent 8080 0 no-query default proxy-only login=fisicasop_fcbog:s4l4fis219
http_port 10000
acl port10000 myport 10000
cache_peer_access 168.176.239.30 allow port10000
  #+end_src
* NOTES
  #+begin_src shell
alias psshn="pssh -i -A  -h /home/oquendo/MYHOSTS  -O StrictHostKeyChecking=no -O UserKnownHostsFile=/dev/null  -O  GlobalKnownHostsFile=/dev/null"

psshn 'echo "check_certificate = off" > /root/.wgetrc'
psshn 'source /root/.bashrc ; slackpkg -batch=on -default_answer=y update '
#psshn 'killall -9 slackpkg; rm -f /var/lock/slackpkg.* '
psshn 'source /root/.bashrc ; slackpkg -batch=on -default_answer=y upgrade patches '

  #+end_src
