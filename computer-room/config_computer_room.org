#+TITLE:Computer room in slackware : Server and client config
#+AUTHOR: William Oquendo
#+email: woquendo@gmail.com
#+INFOJS_OPT: 
#+STARTUP: Overview
#+BABEL: :session *R* :cache yes :results output graphics :exports both :tangle yes 
-----

This document presents a basic procedure to configure a computer room
in slackware. This generates a script, called
=bootsrap_slackware_computer_room.sh= that uses a bunch of config files to setup
either a client or a server. The script will read a configuration file, like
=computer_room.conf=, to set some environment vars.  At the end
you just run the mentioned script and hopefully everything will work
as expected. 

- Check https://www.redhat.com/sysadmin/my-survival-kit

* Description
  - The system to be installed is slackware 14.2-current 64bits, although some script
    might help to keep it updated with security patches
  - Services to be configured:
    - DHCP + DNS + MASQUERADING : Using dnsmasq
    - NAT : Through arno iptables firewall
    - NIS : For now ...
    - NFS
    - Optional : Backup
  - Server is assumed to have two nics, one external (=eth0=), one
    internal (=eth1=)
  - The internal network of class C will use the segment 192.168.10.0/24

* Slackware installation
Just download it from the official slackware web page. Get the dvd
version. Install everything. It is advisable to have at least four
partitions: one for root, one for swap, one for home, and one for tmp.
  
Then use the configuration script on ~../configurations~ to config
the slackware machine.

As of 2019, clonezilla is used to image a golden image from a virtual machine
install into each computer.

* Configuration of client and server for a computer room
** Parameters to configure bootstrap script
#+begin_src sh :exports code :tangle scripts/computer_room.conf
BASE_SERVERIP=192.168 
SERVERIP=${BASE_SERVERIP}.10.1
NISDOMAIN=salafisnis
SERVER_DOMAINNAME=serversalafis
FORCE=0 # Force rewrite of all config even if it is already configured

## Proxy stuff : removed auth info since I will be using a cntlm config on the server
# UNAL
#PROXY=fisicasop_fcbog:PASSWD@proxyapp.unal.edu.co:8080
# local cntlm config running on server
PROXY=${SERVERIP}:3128
#+end_src
** Configuring root internet behind proxy unal
   #+NAME: proxy_config
   #+BEGIN_SRC bash :exports code 
# Configure root internet access
function config_proxy {
    MSG="Configuring proxy for root"
    start_msg "$MSG"
    bname="/root/.bashrc"
    if [ x"" == x"$(grep https_proxy ${bname})" ] || [ $FORCE -eq 1 ] ; then
	touch $bname
	backup_file $bname
	cat <<EOF > $bname
export PROXY="$PROXY"
export http_proxy="http://\$PROXY"
export https_proxy="http://\$PROXY" 
export ftp_proxy="ftp://\$PROXY"
export RSYNC_PROXY="\$PROXY" 
EOF
    else
	echo "#    -> already configured."
    fi
    source /root/.bashrc
    end_msg "$MSG"
}
   #+END_SRC
** Configure Network interfaces
   #+name: nic_config
   #+BEGIN_SRC bash :exports code 
# network interfaces
function config_network {
    MSG="Configuring network interfaces "
    start_msg "$MSG"
    if [ "$TARGET" == "SERVER" ]; then
	#if [ $(pattern_not_present "127.0.0.1" "/etc/resolv.conf.head") ]; then
	if [ x"" == x"$(grep 127.0.0.1 /etc/resolv.conf.head)" ] || [ $FORCE -eq 1 ] ; then
	    echo "Setting up resolv.conf.head "
	    TFILE="/etc/resolv.conf.head"
	    copy_config "$FDIR/SERVER-etc-resolv.conf.head" "$TFILE"
	fi	
	#if [ $(pattern_not_present "$SERVERIP" "/etc/rc.d/rc.inet1.conf") ]; then 
	if [ x"" == x"$(grep $SERVERIP /etc/rc.d/rc.inet1.conf)" ] || [ $FORCE -eq 1 ] ; then
	    bash /etc/rc.d/rc.networkmanager stop
	    chmod -x /etc/rc.d/rc.networkmanager
	    copy_config "$FDIR/SERVER-etc-rc.d-rc.inet1.conf" /etc/rc.d/rc.inet1.conf
	else
	    echo "Already configured, just restarting services ..."
	fi
	/etc/rc.d/rc.inet1 restart
    else
	echo "# Creating Network Manager hook"
	if [ ! -f "/etc/NetworkManager/dispatcher.d/90networkmanagerhook.sh" ] || [ $FORCE -eq 1 ]; then
	    cp $FDIR/CLIENT-90networkmanagerhook.sh /etc/NetworkManager/dispatcher.d/90networkmanagerhook.sh
	    chmod +x /etc/rc.d/rc.networkmanager
	    bash /etc/rc.d/rc.networkmanager restart
	    /etc/rc.d/rc.inet2 restart
	else
	    echo "#    -> already configured."
	fi
    fi
    end_msg "DONE: $MSG"
}
   #+END_SRC

** Client ntp
   #+name:ntp_config
   #+begin_src sh 
# ntp server
function config_ntp {
    MSG="Configuring ntp "
    if [ "$TARGET" == "CLIENT" ]; then
	start_msg "$MSG"
	#if [ $(pattern_not_present "$SERVERIP" "/etc/ntp.conf") ]; then
	if [ x"" == x"$(grep $SERVERIP /etc/ntp.conf)" ] || [ $FORCE -eq 1 ] ; then
            echo "STATUS -> $(pattern_not_present "$SERVERIP" "/etc/ntp.conf")"
	    bfile=/etc/ntp.conf
	    backup_file $bfile
	    cp -f $FDIR/CLIENT-ntp-client.conf $bfile
	    chmod +x /etc/rc.d/rc.ntpd
	    /etc/rc.d/rc.ntpd restart
	else
	    echo "#    -> already configured"
	fi
    else
	echo "# Not configuring ntp on server"
    fi
    end_msg "$MSG"
}
   #+end_src

** dnsmasq : dhcp, dns, masquerading
   #+name: dnsmasq_config
   #+BEGIN_SRC bash :exports code 
# dnsmasq
function config_dnsmasq {
    MSG="Configuring dnsmasq "
    start_msg "$MSG"
    if [ "$TARGET" == "SERVER" ]; then
	TFILE="/etc/dnsmasq.conf"
	if [ ! -f $TFILE ] || [ $FORCE -eq 1 ]; then  
	    copy_config "$FDIR/SERVER-etc-dnsmasq.conf" "$TFILE"
	    TFILE="/etc/dnsmasq-hosts.conf"
	    copy_config "$FDIR/SERVER-etc-dnsmasq-hosts.conf" "$TFILE"
	    chmod +x /etc/rc.d/rc.dnsmasq 
	    TFILE="/etc/hosts"
	    copy_config "$FDIR/SERVER-etc-hosts" "$TFILE"
	else
	    echo "Already configured. Restarting services ..."
	fi
	chmod +x /etc/rc.d/rc.dnsmasq 
	/etc/rc.d/rc.dnsmasq restart
    else
        echo "Not configuring on client" 
    fi
    end_msg "$MSG"
}
   #+END_SRC

** Firewall ( also for NAT) : Arno iptables firewall.
I will use arno iptables firewall because it has worked pretty well
before . It must be installed before this step. If not installed , I
will try to use slpkg to install it.

   #+NAME: firewall_config
   #+BEGIN_SRC bash :exports code
# firewall 
function config_firewall {
    MSG="Configuring firewall "
    if [ "$TARGET" == "SERVER" ]; then
	start_msg "$MSG"
	if $(command_exists arno-iptables-firewall) && [[ $FORCE -eq 0 ]]; then
	    echo "    -> firewall already installed and configured."
	else
	    #sbopkg -e stop -B -k -i arno-iptables-firewall
	    source /root/.bashrc
	    slpkg upgrade
	    #slpkg -s sbo arno-iptables-firewall-2.0.1e-noarch-3_SBo
	    slpkg -s sbo arno-iptables-firewall
	    ln -svf /etc/rc.d/rc.arno-iptables-firewall /etc/rc.d/rc.firewall
	    copy_config "$FDIR/SERVER-firewall.conf" "/etc/arno-iptables-firewall/firewall.conf"
	    chmod o-rwx /etc/arno-iptables-firewall/firewall.conf
	    chmod +x /etc/rc.d/rc.arno-iptables-firewall
	fi
	/etc/rc.d/rc.firewall restart
	end_msg "$MSG"
    fi
    # read
}
   #+END_SRC
** NFS
   #+NAME: nfs_config
   #+BEGIN_SRC bash :exports code 
# nfs
function config_nfs {
    MSG="Configuring nfs "
    start_msg "$MSG"
    if [ "$TARGET" == "SERVER" ]; then
	    #if [ $(pattern_not_present "$BASE_SERVERIP" "/etc/hosts.allow") ]; then
	    if [ x"" == x"$(grep $BASE_SERVERIP /etc/hosts.allow)" ] || [ $FORCE -eq 1 ] ; then
	        copy_config "$FDIR/SERVER-etc-hosts.allow" "/etc/hosts.allow"
	    else
            echo "hosts allow already configured"
	    fi
	    #if [ $(pattern_not_present "$SERVERIP" "/etc/exports") ]; then
	    if [ x"" == x"$(grep $SERVERIP /etc/exports)" ] || [ $FORCE -eq 1 ] ; then
	        copy_config "$FDIR/SERVER-etc-exports" "/etc/exports"
	    else
	        echo "Exports already configured. Restarting services ..."
	    fi
	    chmod +x /etc/rc.d/rc.nfsd 
	    /etc/rc.d/rc.nfsd restart
	    /etc/rc.d/rc.inet2 restart
	    echo "NOTE: If you have NFS problems, consider editing the /etc/hosts.allow and /etc/hosts.deny files"
    else
	    bfile="/etc/fstab"
	    #if [ $(pattern_not_present "${SERVERIP}" "$bfile") ]; then
	    if [ x"" == x"$(grep ${SERVERIP} ${bfile})" ] || [ $FORCE -eq 1 ] ; then
	        backup_file $bfile
	        echo "# NEW NEW NEW NFS stuff " >> $bfile
	        echo "${SERVERIP}:/home     /home   nfs     rw,hard,intr,usrquota  0   0" >> $bfile
	    else
	        echo "#    -> already configured"
	    fi
    fi
    end_msg "$MSG"
}
   #+END_SRC
** NIS
   #+NAME: nis_config
   #+BEGIN_SRC bash :exports code
# nis
function config_nis {
    MSG="Configuring nis "
    start_msg "$MSG"
    chmod +x /etc/rc.d/rc.yp
    if [ "$TARGET" == "SERVER" ]; then
	    if [ x"" == x"$(grep $BASE_SERVERIP /etc/hosts.allow)" ] || [ $FORCE -eq 1 ] ; then
	        copy_config "$FDIR/SERVER-etc-hosts.allow" "/etc/hosts.allow"
	    else
            echo "hosts allow already configured"
	    fi

        #if [ $(pattern_not_present "${NISDOMAIN}" "/etc/defaultdomain") ] ; then
	    if [ x"" == x"$(grep $NISDOMAIN /etc/defaultdomain)" ] || [ $FORCE -eq 1 ] ; then
            copy_config "$FDIR/SERVER-etc-defaultdomain" "/etc/defaultdomain"
        else
            echo "Already configured default nis domain"
        fi
        #if [ $(pattern_not_present "${NISDOMAIN}" "/etc/yp.conf") ] ; then
	    if [ x"" == x"$(grep $NISDOMAIN /etc/yp.conf)" ] || [ $FORCE -eq 1 ] ; then
            copy_config "$FDIR/SERVER-etc-yp.conf" "/etc/yp.conf"
            copy_config "$FDIR/SERVER-var-yp-Makefile" "/var/yp/Makefile"
        else
            echo "Already configured yp"
        fi

        backup_file /etc/rc.d/rc.yp
        if [ x"" == x"$(grep 'YP_SERVER_ENABLE=1' /etc/rc.d/rc.yp 2>/dev/null)"]; then
            sed -i.bck 's/YP_CLIENT_ENABLE=.*/YP_CLIENT_ENABLE=0/ ; s/YP_SERVER_ENABLE=.*/YP_SERVER_ENABLE=1/ ;' /etc/rc.d/rc.yp
        else
            echo "Already configured as yp server"
        fi

        echo "Running nis services ..."
        ypserv
        make -BC /var/yp
        #/usr/lib64/yp/ypinit -m
    else # CLIENT
        chmod +x /etc/rc.d/rc.nfsd
        chmod +x /etc/rc.d/rc.yp
        #if [ $(pattern_not_present "${NISDOMAIN}" "/etc/defaultdomain") ]; then
	    if [ x"" == x"$(grep $NISDOMAIN /etc/defaultdomain)" ] || [ $FORCE -eq 1 ] ; then
            bfile="/etc/defaultdomain"
            backup_file $bfile
            echo ${NISDOMAIN} > $bfile
	        bfile="/etc/rc.d/rc.local"
	        backup_file $bfile
	        echo 'nisdomainname -F /etc/defaultdomain' > $bfile
            bfile="/etc/yp.conf"
            backup_file $bfile
            echo "ypserver ${SERVERIP}" > $bfile
            bfile=/etc/nsswitch.conf
            backup_file $bfile
            cp -f $FDIR/CLIENT-nsswitch.conf $bfile
            bfile="/etc/passwd"
            backup_file $bfile
            echo +:::::: >> $bfile
            bfile="/etc/shadow"
            backup_file $bfile
            echo +:::::::: >> $bfile
            bfile="/etc/group"
            backup_file $bfile
            echo +::: >> $bfile
            if [ x"" == x"$(grep 'YP_CLIENT_ENABLE=1' /etc/rc.d/rc.yp) 2>/dev/null" ]; then
                backup_file /etc/rc.d/rc.yp
                sed -i.bck 's/YP_CLIENT_ENABLE=.*/YP_CLIENT_ENABLE=1/ ; s/YP_SERVER_ENABLE=.*/YP_SERVER_ENABLE=0/ ;' /etc/rc.d/rc.yp
            fi
            # Remove the broadcast option
            backup_file /etc/default/yp
            echo 'YPBIND_OPTS=" "' >> /etc/default/yp
        else
            echo "#    -> already configured."
        fi
    fi
    nisdomainname -F /etc/defaultdomain
    end_msg "$MSG"
}
     #+END_SRC
** Client: Copy public id for password-less access and allow root login
   #+name:publicid_config
   #+begin_src sh 
function config_publicid_sshpassword {
    if [ "$TARGET" == "CLIENT" ]; then 
	MSG="Copying server public key  to configure passwordless access for root"
	start_msg "$MSG"
	mkdir -p /root/.ssh &>/dev/null
	#if [ $(pattern_not_present "${SERVER_DOMAINNAME}" "/root/.ssh/authorized_keys") ]; then
	if [ x"" == x"$(grep $SERVER_DOMAINNAME /root/.ssh/authorized_keys)" ] || [ $FORCE -eq 1 ] ; then
	    cat $FDIR/CLIENT-server_id_rsa.pub >> /root/.ssh/authorized_keys
	    chmod 700 /root/.ssh
	    chmod 640 /root/.ssh/authorized_keys
	else
	    echo "#    -> already configured"
	fi
	end_msg "$MSG"
	
	MSG="Allowing root login for client"
	start_msg "$MSG"
	bfile="/etc/ssh/sshd_config"
	if [ x"" == x"$(grep '^PermitRootLogin.*yes' $bfile)" ] || [ $FORCE -eq 1 ] ; then
	    backup_file $bfile
	    echo "PermitRootLogin yes" >> $bfile
	    /etc/rc.d/rc.sshd restart
	else
	    echo "#    -> already_configured"
	fi
	end_msg "$MSG"
    fi

}
   #+end_src
** Remove permissions to halt/shutdown from button and gui (todo)
   #+name:shutdown_config
   #+begin_src sh
function config_shutdown_perms {
    MSG="Removing permissions to reboot/halt system"
    start_msg "$MSG"
    fname=disallow-power-options.rules
    if [ ! -f /etc/polkit-1/rules.d/$fname ] || [ $FORCE -eq 1 ]; then
	chmod o-x /sbin/shutdown 
	chmod o-x /sbin/halt
	cp $FDIR/$fname /etc/polkit-1/rules.d/
    else
	echo "#    -> polkit rules already configured"
    fi

    tfname=/etc/acpi/acpi_handler.sh
    #if [ $(pattern_not_present "emoves" "$tfname") ]; then
    if [ x"" == x"$(grep emoves ${tfname})" ] || [ $FORCE -eq 1 ] ; then
	copy_config $FDIR/etc-acpi-acpi_handler.sh $tfname
    else
	echo "#   -> Acpi handler already configured"
    fi

    end_msg "$MSG"
}
   #+end_src
** Crontab
   This crontab reads a given script and runs it every some time
   #+name:crontab_config
   #+begin_src sh :exports code 
function config_crontab {
    MSG="Configuring crontab per minute, hour, daily, etc"
    start_msg "$MSG"
    crontab -l > /tmp/crontab
    if [ "$TARGET" == "SERVER" ]; then
	if [ x"" == x"$(grep minute_maintenance.sh /tmp/crontab)" ] || [ $FORCE -eq 1 ] ; then
	    crontab $FDIR/SERVER-crontab -u root
	else
	    echo "#    -> Already configured (per minute)"
	fi
	TNAME="/etc/cron.daily/daily_maintenance.sh"
	if [ ! -f $TNAME ] || [ $FORCE -eq 1 ]; then
            copy_config $FDIR/SERVER-cron/daily_maintenance.sh "$TNAME"
	else
            echo "#    -> Already configured (daily)"
	fi
    else # CLIENT
	if [ x"" == x"$(grep check_status.sh /tmp/crontab)" ] || [ $FORCE -eq 1 ] ; then
	    crontab $FDIR/CLIENT-crontab -u root
	else
	    echo "#    -> Already configured"
	fi
    fi
    end_msg "$MSG"
}
   #+end_src
** PACKAGES
   Crontab will check, every hour, for two options
    1. *Recommended*: It will use ~slpkg~ to install all packages
       specified inside the file ~/home/PACKAGES.list~ . This will
       compile everything on each client, taking more time on the
       slowest, but will make sure that all clients will conform with
       their own installed libs.
    2. *Alternative, not recommended* It will install the contents
       inside the folder ~/home/PACKAGES/~ . It is assumed that home
       is exported on NFS, so all clients will see that file. Packages
       inside that folder might require dependencies also to be inside
       that folder. This is useful if one setups a package building
       server and then copy all the packages inside the named folder,
       but this assumes that all clients have the same libs installed,
       so it depends on the homogeneity of the clients.

   This uses the ~/home/PACKAGES.list~ approach read by the weekly
   cronjob to install the needed packages. Of course, it can be run
   sooner when needed.
   #+name: packages_config
   #+begin_src shell
function config_packages {
    MSG="Creating package list"
    start_msg "$MSG"
    if [ "$TARGET" == "SERVER" ]; then
	    if [ ! -f /home/PACKAGES.list ]; then
	        cat << EOF > /home/PACKAGES.list
bonnie++ arno-iptables-firewall iotop wol squid tor  autossh  parallel sshfs-fuse xfce4-xkb-plugin
dropbox ffmpeg syncthing
ganglia ganglia-web glusterfs rrdtool papi openmpi hdf5 
octave qtoctave codeblocks geany kdiff3 kile 
R grads rstudio-desktop cdo 
obs-studio ssr asciinema 
EOF
	    fi  
    fi
    end_msg "$MSG"
}
   #+end_src
** Install and configure monit (pending on clients and complement on server)
Monit is a tool that allows to monitor and restart if needed
different services, files, etc. This will be another level of
redundancy (besides the scripts in crontab) to keep services
running. TODO: configure essential services on server and clients.
   #+name:monit_config
   #+begin_src sh :exports code
function config_monit {
    MSG="Configuring monit on server "
    start_msg "$MSG"
	if $(command_exists monit) && [[ $FORCE -eq 0 ]]; then
	    echo "#    -> already installed"
	else
        echo "Installing monit ..."
        source /root/.bashrc
	    slpkg -s sbo monit
    fi
	chmod +x /etc/rc.d/rc.monit
    echo "Configuring monit ..."
    if [ x"" == x"$(grep -e '^include' /etc/monitrc)" ]; then 
	    backup_file /etc/monitrc
        echo 'include /etc/monit.d/*' >> /etc/monitrc
    fi  
    if [ ! -d /etc/monit.d ]; then
        mkdir /etc/monit.d
    fi
    if [ x"" == x"$(grep -e 'monit' /etc/inittab)" ]; then
	    backup_file /etc/inittab
        echo '# Run monit in standard runlevels' >> /etc/inittab
        echo 'mo:2345:respawn:/usr/bin/monit -Ic /etc/monitrc' >> /etc/inittab
    fi
	copy_config "$FDIR/common-monitrc" "/etc/monit.d/00-common-monitrc"
	copy_config "$FDIR/${TARGET}-monitrc" "/etc/monit.d/01-${TARGET}-monitrc"
	/etc/rc.d/rc.monit restart
    end_msg "$MSG"
}
   #+end_src
** cntlm 
This allows to create a bypassing proxy that handles all auth and
allows for computers to use  a simple proxy with no auth. For
instance, with this I can now use emacs and install packages
without much hassle.
   #+name:cntlm_config
   #+begin_src sh :exports code
function config_cntlm {
    MSG="Configuring cntlm on server "
    start_msg "$MSG"
    if [ "$TARGET" == "SERVER" ]; then 
	if $(command_exists cntlm) && [ $FORCE -eq 0 ]; then
	    echo "#    -> already installed"
	else
	    source /root/.bashrc
	    slpkg -s sbo cntlm
	    chmod +x /etc/rc.d/rc.cntlm 
	    backup_file /etc/cntlm.conf
	    copy_config "$FDIR/SERVER-etc-cntlm.conf" "/etc/cntlm.conf"
	    echo "Please write the password for the account to be used with cntlm"
	    cntlm -H > /tmp/cntlm-hashed
	    cat /tmp/cntlm-hashed >> /etc/cntlm.conf
	    rm -f /tmp/cntlm-hashed
	    /etc/rc.d/rc.cntlm restart
	fi
    else
	echo "Not configuring on client."
    fi
    end_msg "$MSG"
}
   #+end_src
** _DEPRECATED_ pssh: Already installed, use the following links to fix the password
   - https://unix.stackexchange.com/questions/128974/parallel-ssh-with-passphrase-protected-ssh-key
   - https://www.funtoo.org/Keychain
   - https://stackoverflow.com/questions/43597283/pass-the-password-as-an-argument-in-pssh
   - https://www.golinuxcloud.com/pssh-public-key-authentication-passwordless/
** cluster ssh
Check some tutorial at
https://www.2daygeek.com/clustershell-clush-run-commands-on-cluster-nodes-remote-system-in-parallel-linux/
#+name: clustershell
#+begin_src sh :exports code
function config_clustershell {
    MSG="Installing and configuring clustershell on server... "
    start_msg "$MSG"
    if [ "$TARGET" == "SERVER" ]; then
        echo "Installing ..."
	    if $(command_exists clush) && [ $FORCE -eq 0 ]; then
	        echo "#    -> already installed"
	    else
	        source /root/.bashrc
            pip install cluster-shell
        fi
        echo "Configuring ..."
        if [ ! -d /etc/clustershell ]; then
            mkdir -p /etc/clustershell
        fi
        if [ ! -f /etc/clustershell/clush.conf ]; then
	        copy_config "$FDIR/SERVER-etc-clustershell-clush.conf" "/etc/clustershell/clush.conf"
        else
            echo "clush.conf already existing."
        fi
        if [ ! -f /etc/clustershell/groups.d/salafis.yaml ]; then
            mkdir -p /etc/clustershell/groups.d/
	        copy_config "$FDIR/SERVER-etc-clustershell-groupsd-salafis.yaml" "/etc/clustershell/groups.d/salafis.yaml"
        else
            echo "group salafis.yaml already existing".
        fi
    else
	    echo "Not configuring on client."
    fi
    end_msg "$MSG"
}
   #+end_src
** x2goserver (server)
#+name: x2go
#+begin_src shell :exports code
function config_x2go {
    MSG="Installing and configuring x2go server "
    start_msg "$MSG"

    echo "Preconfiguring ... "
    if [ "$TARGET" == "SERVER" ]; then
        echo "Adding x2gouser user and x2goprint group ..."
        groupadd -g 290 x2gouser
        useradd -u 290 -g 290 -c "X2Go Remote Desktop" -M -d /var/lib/x2go -s /bin/false x2gouser
        groupadd -g 291 x2goprint
        mkdir -p /var/spool/x2goprint &>/dev/null
        useradd -u 291 -g 291 -c "X2Go Remote Desktop" -m -d /var/spool/x2goprint -s /bin/false x2goprint
        chown x2goprint:x2goprint /var/spool/x2goprint
        chmod 0770 /var/spool/x2goprint
    fi

    echo "Installing ..."
    	if $(command_exists x2goversion) && [[ $FORCE -eq 0 ]]; then
	    echo "#    -> already installed"
	else
        echo "Installing x2go ..."
        source /root/.bashrc
	    slpkg -s sbo x2goserver
        /etc/rc.d/rc.inet2 restart
        x2godbadmin --createdb
    fi

    end_msg "$MSG"
}
#+end_src
** Write final script
#+BEGIN_SRC bash :exports code :noweb yes :tangle scripts/bootstrap_slackware_computer_room.sh :tangle-mode (identity #o444)
#!/bin/bash

# NOTE: The original base file is in the config_computer_room.org file
# Color stuff based on: https://devdojo.com/bobbyiliev/how-to-create-an-interactive-menu-in-bash#testing-the-script

SCRIPTS_DIR=$HOME/repos/computer-labs/computer-room/scripts
CONFIG=${CONFIG:-computer_room.conf}

if [ ! -f $CONFIG ]; then
    echo "ERROR: Config file not found -> $CONFIG"
    exit 1
fi
source $CONFIG
source $SCRIPTS_DIR/util_functions.sh

# check args
if [ "$#" -ne "2" ]; then usage; exit 1 ; fi
if [ ! -d "$1" ]; then echo "Dir does not exist : $1"; usage; exit 1 ; fi
if [  "$2" != "SERVER" ] && [ "$2" != "CLIENT" ]; then usage; exit 1 ; fi

TARGET="$2"
# global vars
BDIR=$PWD
FDIR=$1
LINUX="SLACKWARE"

##
# Color  Variables
##
red='\e[31m'
green='\e[32m'
yellow='\e[33m'
blue='\e[34m'
magenta='\e[35m'
cyan='\e[36m'
lred='\e[91m'
lgreen='\e[92m'
lyellow='\e[93m'
lblue='\e[94m'
lmagenta='\e[95m'
lcyan='\e[96m'
white='\e[97m'
clear='\e[0m'

##
# Color Functions
##

ColorGreen(){
	echo -ne $green$1$clear
}
ColorLGreen(){
	echo -ne $lgreen$1$clear
}
ColorBlue(){
	echo -ne $blue$1$clear
}
ColorCyan(){
	echo -ne $cyan$1$clear
}
ColorYellow(){
	echo -ne $yellow$1$clear
}

echo "###############################################"
echo "# Configuring $TARGET ..."
if [[ $FORCE -eq 1 ]]; then
    echo "# Forcing configuration ...";
fi
echo "###############################################"

<<proxy_config>>

<<nic_config>>

<<ntp_config>>

<<dnsmasq_config>>

<<firewall_config>>

<<nfs_config>>

<<nis_config>>

<<monit_config>>

<<publicid_config>>

<<shutdown_config>>

<<crontab_config>>

<<packages_config>>

<<cntlm_config>>

<<x2go>>

# Call all functions
all ()
{
    config_proxy
    config_network
    config_ntp
    config_dnsmasq
    config_firewall
    config_nfs
    config_nis
    config_monit
    config_publicid_sshpassword
    config_shutdown_perms
    config_crontab
    config_packages
    config_cntlm
    config_x2go
    config_clustershell
}

menu(){
echo -ne "
Services to configure on: $TARGET
$(ColorGreen '1)') proxy
$(ColorGreen '2)') network (rc.inet1.conf)
$(ColorGreen '3)') ntp
$(ColorGreen '4)') dnsmasq
$(ColorGreen '5)') firewall
$(ColorGreen '6)') nfs
$(ColorGreen '7)') nis
$(ColorGreen '8)') monit
$(ColorGreen '9)') public sshkey
$(ColorGreen '10)') shutdown perms
$(ColorGreen '11)') crontab
$(ColorGreen '12)') packages
$(ColorGreen '13)') cntlm
$(ColorGreen '14)') x2go
$(ColorGreen '15)') clustershell
$(ColorLGreen '16)') Configure ALL
$(ColorYellow '0)') Exit
$(ColorCyan 'Choose an option:') "
        read a
        case $a in
	        1) config_proxy ; menu ;;
	        2) config_network ; menu ;;
	        3) config_ntp ; menu ;;
	        4) config_dnsmasq ; menu ;;
	        5) config_firewall ; menu ;;
	        6) config_nfs ; menu ;;
	        7) config_nis ; menu ;;
	        8) config_monit ; menu ;;
	        9) config_publicid_sshpassword ; menu ;;
	        10) config_shutdown_perms ; menu ;;
	        11) config_crontab ; menu ;;
	        12) config_packages ; menu ;;
	        13) config_cntlm ; menu ;;
	        14) config_x2go ; menu ;;
	        15) config_clustershell ; menu ;;
	        16) all ; menu ;;
		0) exit 0 ;;
		,*) echo -e $lred"Wrong option."$clear; exit 1;;
        esac
}


menu

# run services (better done on script that keeps the system up, when the client is on the network)
#/etc/rc.d/rc.nfsd restart
#mount -a
#/etc/rc.d/rc.yp restart
#/etc/rc.d/rc.inet2 restart
#rpcinfo -p localhost


#+END_SRC

* Auxiliary scripts
** Create an user
  #+BEGIN_SRC sh :exports code :mkdirp yes :tangle scripts/create_user.sh 
     #!/bin/bash                                                                                                               
     if [ x"" != x"$1" ]; then
	 adduser $1
	 usermod -a -G audio,cdrom,floppy,plugdev,video,power,netdev,lp,scanner $1
	 make -BC /var/yp
	 #su - $1                                                                                                              
	 #xwmconfig                                                                                                            
     else
	 echo "Error. Debes llamar este script como:"
	 echo "bash $0 nombredeusuarionuevo"
     fi

  #+END_SRC
   
** Check and delete inactive users
   - Find inactive users
     #+BEGIN_SRC sh :exports code :tangle scripts/get_inactive.sh
DAYS=180
OFILE=/root/inactive_users.txt
echo > $OFILE
for dname in /home/*; do 
    if [ -d $dname ]; then 
	result=$(find "${dname}" -mtime -${DAYS} -type f -print -quit)
	if [[ $result == "" ]]; then
	    echo "User home has been inactive for more than ${DAYS} days : $dname"
	    echo "${dname#/home/}" >> $OFILE
	fi
    fi
done
echo "###########################################"
echo "Inactive users wrote to $OFILE"
      
     #+END_SRC
   - Delete inactive users
     #+BEGIN_SRC  sh :exports code :tangle scripts/del_inactive.sh
for a in $(cat /root/inactive_users.txt); do
    if [ "$a" == "ramezquitao" ] || [ "$a" == "ersanchezp" ] || [ "$a" == "jdmunozc" ] || [ "$a" == "jbaena" ] || [ "$a" == "oquendo" ]; then
        echo "skipping account : $a"
        continue
    fi
    echo "deleting $a"
    userdel -rf $a;
done
     #+END_SRC
** User disk usage
   #+BEGIN_SRC sh :exports code :mkdirp yes :tangle scripts/user_disk_usage.sh
      echo "Computing user disk usage ... "
      for a in /home/*; do 
	  du -sh $a ; 
      done | sort -rh > user_disk_usage.txt
      echo "################################"
      echo "DONE: results sorted and wrote to user_disk_usage.txt"

   #+END_SRC
** Create users from csv list with usernames and ids
   This script reads a list of usernames and passwords and creates the
   corresponding users
   #+begin_src sh :exports code :tangle scripts/create_users_from_list.sh :tangle-mode (identity #o444)
#!/bin/bash

FNAME=${1}
if [[ ! -f $FNAME ]]; then
    echo "Error: filename $FNAME does not exists"
    exit 1
fi

while read line
do
    username=$(echo $line | awk '{print $1}')
    password=$(echo $line | awk '{print $2}')
    echo username=$username
    echo password=$password
    # echo "Deleting account $username"
    # userdel $username
    echo Creating account $username
    useradd -d /home/$username -G audio,cdrom,floppy,plugdev,video -m -s /bin/bash $username 
    echo "Changing password for $username to ${password}"
    echo ${username}:${password} | chpasswd
    #echo "Recursive chown ... &"
    #chown -R $username.$username /home/$username &
done < $FNAME

read

echo "Updating nis database"
make -C /var/yp/
service portmap restart
service ypserv  restart
echo "DONE."

   #+end_src
** Recreate users from folders inside home 
   This is useful when the server was reinstalled
   #+begin_src sh :exports code :tangle scripts/recreate_users_from_directories.sh :tangle-mode (identity #o444)
#!/bin/bash

for usernamedir in /home/*; do 
    if [ -d $usernamedir ]; then
	username=$(basename $usernamedir)
	if [ "ftp" != "$username" ] && [ "localuser" != "$username" ] ; then 
	    #echo "Deleting account $username"
	    #userdel $username
	    echo Creating account $username
	    useradd -d /home/$username -G audio,cdrom,floppy,plugdev,video -m -s /bin/bash $username
	    echo "Changing password for $username to ${username}123"
	    echo ${username}:${username}123 | chpasswd 
	    echo "Recursive chown ... &"
	    chown -R $username.$username /home/$username & 
	fi
    fi
done
echo "Updating nis database"
make -C /var/yp/
service portmap restart
service ypserv  restart

echo "DONE."

   #+end_src
** Data dir for users
In case there are some hard disk space to share between users,
create directories for each one
   #+begin_src sh  :exports code :tangle scripts/create_data_dirs_for_users.sh :tangle-mode (identity #o444)
#!/bin/bash

for a in /home/*; do
    bname=$(basename $a)
    id -u $bname &> /dev/null
    status=$?
    #echo $bname
    #echo $status
    if [[ "0" -eq "$status" ]]; then
	for b in data01 data02; do
	    mkdir -p /mnt/local/$b/$bname	    
	    chown -R $bname.$bname /mnt/local/$b/$bname
	done
    fi
done
   #+end_src

** Burn slackware live
  - live
    #+BEGIN_SRC sh :tangle scripts/burn_slackware_live.sh
USBKEYS=($(
    grep -Hv ^0$ /sys/block/*/removable |
    sed s/removable:.*$/device\\/uevent/ |
    xargs grep -H ^DRIVER=sd |
    sed s/device.uevent.*$/size/ |
    xargs grep -Hv ^0$ |
    cut -d / -f 4
))

echo "Burning slackware image iso to /dev/sd{b,c,d,e,f,g,h} -> ${USBKEYS[*]}"
parallel --gnu "dd if=/root/dev-iso/slackware64-live-current.iso of=/dev/{} " ::: ${USBKEYS[*]}
if [ "$?" == "0" ]; then
    sync
    echo "Done. Please test the usb on another computer"
else
    echo "Some error ocurred. Exiting."
fi
    #+END_SRC
  - With persistence
    #+BEGIN_SRC sh :tangle scripts/burn_slackware_live_persistence.sh
USBKEYS=($(
    grep -Hv ^0$ /sys/block/*/removable |
    sed s/removable:.*$/device\\/uevent/ |
    xargs grep -H ^DRIVER=sd |
    sed s/device.uevent.*$/size/ |
    xargs grep -Hv ^0$ |
    cut -d / -f 4
))
echo "Burning slackware image iso with persistence to /dev/sd{b,c,d,e,f,g,h} -> ${USBKEYS[*]}"
#parallel --gnu bash /root/dev-iso/liveslak/iso2usb.sh -i /root/dev-iso/slackware64-live-current.iso -o /dev/{} -u -v -w 30  ::: ${USBKEYS[*]}
bash /root/dev-iso/liveslak/iso2usb.sh -i /root/dev-iso/slackware64-live-current.iso -o /dev/${USBKEYS[0]} -u -v -w 30
if [ "$?" == "0" ]; then
    echo "Done. SYncing writing ... "
    sync
    echo "Done. Please test the usb on another computer"
else
    echo "Some error ocurred. Exiting."
fi
    #+END_SRC
** Peformance monitor
  #+BEGIN_SRC sh :exports code :tangle scripts/monitor_perf.sh
    TOTALITER=10800
    iotop -botq --iter=$TOTALITER &>> /tmp/log-iotop
    top -b -n $TOTALITER &>> /tmp/log-top
    /usr/local/sbin/iftop -P -b -i eth0 -t &>> /tmp/log-iftop-eth0
    /usr/local/sbin/iftop -P -b -i eth0 -t &>> /tmp/log-iftop-eth1

    vmstat -a -t 1 $TOTALITER &>> /tmp/log-vmstat
    vmstat -s -t 1 $TOTALITER &>> /tmp/log-vmstat-s
    vmstat -D -t 1 $TOTALITER &>> /tmp/log-vmstat-D

    function runiostat {
	while  [ 1 ]; do
	    sleep 1
	    iostat >> /tmp/log-iostat
    }

    runiostat
  #+END_SRC

** Update patches
#+begin_src shell :tangle scripts/update_patches.sh
alias psshn="pssh -i -A  -h /home/oquendo/MYHOSTS  -O StrictHostKeyChecking=no -O UserKnownHostsFile=/dev/null  -O  GlobalKnownHostsFile=/dev/null"

#psshn 'echo "check_certificate = off" > /root/.wgetrc'
#psshn 'source /root/.bashrc ; slackpkg -batch=on -default_answer=y update '
##psshn 'killall -9 slackpkg; rm -f /var/lock/slackpkg.* '
#psshn 'source /root/.bashrc ; slackpkg -batch=on -default_answer=y upgrade patches'

psshn 'source /root/.bashrc; slpkg upgrade'
psshn "source /root/.bashrc; slpkg -s slack '' --patches"


#+end_src
* Problems and solutions [11/11]
** DONE Solving problems with xinit and xfce for all and new users
CLOSED: [2020-02-29 Sat 19:27]
- Make sure all users are on the video group. Maybe run
  #+BEGIN_SRC bash
usermod -a -G audio,cdrom,floppy,plugdev,video,power,netdev,lp,scanner USERNAME
  #+END_SRC
  on each user.
- Make sure that the minimum gid in yp nis is 2 (see file =/var/yp/Makefile=)

** DONE Dhcpcd                                                    :SLACKWARE:
CLOSED: [2019-10-16 Wed 10:25]
The latest slackware version advertises the nic using a new
identity called iuad or something but the dhcp server at unal does
not read it so I needed to edit the /etc/dhcpcd.conf file and
activate sending the hardware address. Done at the config slackware script.
** DONE Advertising Ethernet speeds for eth1
   CLOSED: [2019-10-16 Wed 10:25]
(Slackware does not have this problem)
The connection from/to server through eth1 was at a maximum of
10MB/s. while the interface supported gigabit. After many tests I
found that by using the command
#+begin_src shell
ethtool -s eth1 advertise 0x010
#+end_src
I was able to advertise up to gigabit and then run at 100MB/s, which
is the least acceptable given the router.

For slackware I added this to the minute_maintenance.sh .

To make this command permanent in debian, I had to add the following
line under the config for ~eth1~ in the file
~/etc/network/interfaces~
#+begin_src shell
post-up /sbin/ethtool -s eth1 advertise 0x010
#+end_src
** DONE Setup dropbox
#+begin_src sh
~/miniconda3/bin/python ~/dropbox.py proxy manual http proxyapp.unal.edu.co 8080 USERNAME PASSWORD
#+end_src
** DONE Instalando paquetes en R desde una cuenta de usuario
Para instalar paquetes desde una cuenta de usuario se usa el comando
normal ~install.packages~ . Pero si se hace desde un computador de
la universidad, es necesario configurar el proxy antes de entrar a
~R~.

*Nota*: Una vez instalados los paquetes no es necesario volver a
instalarlos, pero cada usuario debe instalar sus paquetes en su
cuenta.

*** Configuración del proxy
Existen dos formas de hacerlo. La primera, es la mas sencilla pero
debe hacerse cada vez que se abra una consola nueva. Esta primera
forma consiste en exportar las variables del proxy de la siguiente
manera
#+BEGIN_SRC sh :exports code
export http_proxy="http://USERNAME:PASSWORD@proxyapp.unal.edu.co:8080/"
export https_proxy="http://USERNAME:PASSWORD@proxyapp.unal.edu.co:8080/"
export ftp_proxy="http://USERNAME:PASSWORD@proxyapp.unal.edu.co:8080/"
#+END_SRC
en donde se debe reemplazar =USERNAME= por el nombre del usuario
(de la universidad, sin incluir @unal.edu.co) y =PASSWORD= es el password de
la universidad. En adelante podrá navegar por la consola. Se se
desea que estos comandos siempre se ejecuten al abrir una consola,
se pueden copiar al final del archivo =~/.ḃashrc= .

La segunda forma consiste en añadir el proxy a la información del
profile de =R=. Para esto, debe abrir el archivo oculto
=~.Renviron= (se puede abrir desde el mismo =R= usando el comando
=file.edit('~˙Renviron')=, y escribir allí
#+BEGIN_SRC sh
http_proxy=http://USERNAME:PASSWORD@proxyapp.unal.edu.co:8080/
http_proxy_user=USERNAME:PASSWORD

https_proxy=https://USERNAME:PASSWORD@proxyapp.unal.edu.co:8080/
https_proxy_user=USERNAME:PASSWORD
#+END_SRC
con la convención ya explicada. Este archivo es leido por =R= y por
=R studio=. En adelante, cada vez que se ejecute =R= se cargarán
estas variables.

*** Instalación de paquetes
En este caso simplemente se debe entrar a =R= y ejecutar el comando
#+BEGIN_SRC sh
install.packages(c("ggplot", "dplyr", "p", "rgeos", "digest", "foreign"), repos="https://www.icesi.edu.co/CRAN/")
#+END_SRC
Ese repositorio/mirror está ubicado en Colombia y es rápido, pero se puede
usar cualquier otro.

Los paquetes quedaran instalados en las cuentas locales de los usuarios.
** DONE Formating usb (recovering the usb)
Use gdisk
  #+begin_src sh
   gdisk
   enter recovery
   c
   e
   v
   w
   q
  #+end_src
  #+begin_src sh
   parted /dev/sdb
   mklabel GPT # accept destroying everything
  #+end_src
  Also you can use =cgdisk=.

  To completely delete the fs signatures
  #+begin_src 
   wipefs --all --force /dev/sdb
  #+end_src
** DONE [OLD] Installation  and setup of gdb numpy
   CLOSED: [2019-10-16 Wed 10:30]
  Anaconda creates a lot of problems. It is necessary to clean the path. The command I used was:
  #+begin_src shell
  kash ". ~/.bashrc; . /home/oquendo/PATH.sh; installpkg /home/oquendo/Downloads/pip-9.0.1-x86_64-1_SBo.tgz; pip install matplotlib numpy; cd /home/oquendo/Escritorio/HerrComp/05-Debugging/gdb_numpy-1.0/; python setup.py install"
  #+end_src
  
** DONE [OLD] Anaconda problems with qt
   CLOSED: [2019-10-16 Wed 10:31]
  If some error like "Cannot run ... QT ... xcb plugin ... " appears,
  maybe it needs to fix permissions. Run the following command:
  #+begin_src shell
  sudo chmod 755 /opt/anaconda2/bin/qt.conf
  #+end_src
** DONE [OLD] Ubuntu and related
*** Update git
   #+BEGIN_SRC sh
STATUS="$(grep -re wheezy-backports /etc/apt/sources.list | grep -v grep)"
if [ x"${STATUS}" == x ]; then
    echo "deb http://ftp.debian.org/debian wheezy-backports main" >> /etc/apt/sources.list
fi

apt-get update 

apt-get -t  wheezy-backports install "git" -y   
   #+END_SRC
  
** DONE [OLD] Armadillo problems with anaconda
 When installing armadillo, it finds the anaconda MKL and then a lot
 of problems arise when trying to run progrms with armadillo. This
 happens because putting anaconda bin on the path, in the first
 place, "overwrites" pkgconfig and many other system
 commands. Solution? eliminate anaconda from the path and then use
 alias or simething similar, like linking anaconda python, ipython,
 etc to /usr/local/bin, and no more.

** DONE [OLD] sbopkg behing firewall blocking rsync
   From : https://www.linuxquestions.org/questions/slackware-14/sbopkg-problem-774301/
   1. Download & install TOR from www.torproject.org
   2. Install polipo & torsocks
   3. Run "sudo torsocks sbopkg -r"
   4. Done, repository synced!

* PACKAGES
  This section is used to configure packages that have been already
  installed using the scripts inside the
  [[file:~/repos/computer-labs/packages/]] folder.  Hopefully every
  package will be installed using slpkg.

  - SlackBuild builder: https://alien.slackbook.org/AST/index.php
  - https://blog.spiralofhope.com/15906/slackware-package-managers.html
  - https://blog.spiralofhope.com/22995/checkinstall.html
  - slacktrack:
    https://www.reddit.com/r/slackware/comments/36flus/practices_for_package_maintenance_for_slackware/
  - src2pkg: https://distro.ibiblio.org/amigolinux/download/src2pkg/
  - https://idlemoor.github.io/slackrepo/links.html

** Auxiliary packages
Add alien repo to slpkg and then install libreoffice poppler-compat inkscape vlc
** Spack
   - clone it
   - source env
   - Setup http proxy in .curlrc as proxy = http://user,,,,
   - bootstrap
   - resource env and add this to bashrc
   - Install whatever
   - load whatever with modeule load
   - make an example
** CDO [2019-09-18 Wed]
   Use alien AST
** GRADS [2019-09-18 Wed]
   Use alien AST
** Tortoisehg 2018
   Download the source code (and maybe use src2pkg) and install the
   package. See https://tortoisehg.bitbucket.io/download/source.html
** [OLD] Squid
  #+begin_src sh
   # only access from localhost is allowed
acl localhost src 127.0.0.1/32
acl all src all
http_access allow localhost
http_access deny all
icp_access deny all

never_direct allow all

# turn off cache
cache_dir null /tmp
cache deny all

# logs
access_log /var/log/squid/access.log squid

# turn off proxy-headers (no idea what is it :))
via off
forwarded_for off

# describe external proxy server
cache_peer 168.176.239.30 parent 8080 0 no-query default proxy-only login=fisicasop_fcbog:PASSWD
http_port 10000
acl port10000 myport 10000
cache_peer_access 168.176.239.30 allow port10000
  #+end_src
* Todo [0/1]
- [ ] ldap for auth: link with unal server
