#+TITLE:Computer room in slackware : Server and client config
#+AUTHOR: William Oquendo
#+email: woquendo@gmail.com
#+INFOJS_OPT: 
#+STARTUP: Overview
#+BABEL: :session *R* :cache yes :results output graphics :exports both :tangle yes
-----

This document presents a basic procedure to configure a computer room
in slackware. This generates a script,
=scripts/bootsrap_slackware_computer_room.sh= that uses a bunch of
config files to setup either a client or a server. The script will
read a configuration file, like =computer_room.conf=, to set some
environment vars.  At the end you just run the mentioned script and
hopefully everything will work as expected.

- Check https://www.redhat.com/sysadmin/my-survival-kit
- Check addresses at: https://warewulf.org/docs/enchiridion/setup
  
* Description
  - The system to be installed is slackware64-current, although some
    script might help to keep it updated with security patches
  - Services to be configured:
    - DHCP + DNS + MASQUERADING : Using dnsmasq
    - NAT : Through arno iptables firewall
    - NIS : For now ...
    - NFS
    - Optional : Backup
  - Server is assumed to have two nics, one external (=eth0=), one
    internal (=eth1=)
  - The internal network of class C will use the segment 192.168.10.0/24

* Slackware installation
Just download it from the official slackware web page. Get the dvd
version. Install everything. It is advisable to have at least four
partitions: one for root, one for swap, one for home, and one for tmp.
  
Then use the configuration script on ~../configurations~ to config
the slackware machine.

As of 2019, clonezilla is used to image a golden image from a virtual machine
install into each computer.

* Configuration of client and server for a computer room
** CONFIG: Parameters to configure bootstrap script
#+begin_src sh :exports code :tangle scripts/computer_room.conf
  BASE_SERVERIP=192.168 
  SERVERIP=${BASE_SERVERIP}.10.1
  NISDOMAIN=salafisnis
  SERVER_DOMAINNAME=serversalafis
  FORCE=0 # Force rewrite of all config even if it is already configured

  ## Proxy stuff : removed auth info since I will be using a cntlm config on the server
  # UNAL
  #PROXY=fisicasop_fcbog:PASSWD@proxyapp.unal.edu.co:8080
  # local cntlm config running on server
  PROXY=${SERVERIP}:3128
#+end_src
** PROXY: Configuring root internet behind proxy unal
   #+NAME: proxy_config
   #+BEGIN_SRC bash :exports code 
     # Configure root internet access
     function config_proxy {
	 MSG="Configuring proxy for root"
	 start_msg "$MSG"
	 bname="/root/.bashrc"
	 if [ x"" = x"$(grep https_proxy ${bname} 2>/dev/null)" ] || [ $FORCE -eq 1 ] ; then
	     touch $bname
	     backup_file $bname
	     cat <<EOF > $bname
     export PROXY="$PROXY"
     export http_proxy="http://\$PROXY"
     export https_proxy="http://\$PROXY" 
     export ftp_proxy="ftp://\$PROXY"
     export RSYNC_PROXY="\$PROXY" 
     EOF
	 else
	     echo "#    -> already configured."
	 fi
	 #source /root/.bashrc
	 end_msg "$MSG"
     }
   #+END_SRC
** NETWORK INTERFACES: Configure Network interfaces
   #+name: nic_config
   #+BEGIN_SRC bash :exports code 
# network interfaces
function config_network {
    MSG="Configuring network interfaces "
    start_msg "$MSG"
    if [ "$TARGET" = "SERVER" ]; then
        #if [ $(pattern_not_present "127.0.0.1" "/etc/resolv.conf.head") ]; then
        if [ x"" == x"$(grep 127.0.0.1 /etc/resolv.conf.head 2>/dev/null)" ] || [ $FORCE -eq 1 ] ; then
            echo "Setting up resolv.conf.head "
            TFILE="/etc/resolv.conf.head"
            copy_config "${BDIR}/${FDIR}/SERVER-etc-resolv.conf.head" "$TFILE"
        fi	
        #if [ $(pattern_not_present "$SERVERIP" "/etc/rc.d/rc.inet1.conf") ]; then 
        if [ x"" == x"$(grep $SERVERIP /etc/rc.d/rc.inet1.conf 2>/dev/null)" ] || [ $FORCE -eq 1 ] ; then
            bash /etc/rc.d/rc.networkmanager stop
            chmod -x /etc/rc.d/rc.networkmanager
            copy_config "${BDIR}/${FDIR}/SERVER-etc-rc.d-rc.inet1.conf" /etc/rc.d/rc.inet1.conf
        else
            echo "Already configured, just restarting services ..."
        fi
        #/etc/rc.d/rc.inet1 restart
    else # CLIENT
        echo "# Creating Network Manager hook"
        if [ ! -f "/etc/NetworkManager/dispatcher.d/90networkmanagerhook.sh" ] || [ $FORCE -eq 1 ]; then
            cp ${BDIR}/${FDIR}/CLIENT-90networkmanagerhook.sh /etc/NetworkManager/dispatcher.d/90networkmanagerhook.sh
            chmod +x /etc/rc.d/rc.networkmanager
            #bash /etc/rc.d/rc.networkmanager restart
            #/etc/rc.d/rc.inet2 restart
        else
            echo "#    -> already configured."
        fi
    fi
    end_msg "DONE: $MSG"
}
   #+END_SRC

** NTP: Client ntp
   #+name:ntp_config
   #+begin_src sh 
# ntp server
function config_ntp {
    MSG="Configuring ntp "
    if [ "$TARGET" = "CLIENT" ]; then
	    start_msg "$MSG"
	    #if [ $(pattern_not_present "$SERVERIP" "/etc/ntp.conf") ]; then
	    if [ x"" = x"$(grep $SERVERIP /etc/ntp.conf 2>/dev/null)" ] || [ $FORCE -eq 1 ] ; then
            echo "STATUS -> $(pattern_not_present "$SERVERIP" "/etc/ntp.conf")"
	        bfile=/etc/ntp.conf
	        backup_file $bfile
	        cp -f ${BDIR}/${FDIR}/CLIENT-ntp-client.conf $bfile
	    else
	        echo "#    -> already configured"
	    fi
    else
	    echo "# Server: using default ntp config"
    fi
	chmod +x /etc/rc.d/rc.ntpd
	/etc/rc.d/rc.ntpd restart
    end_msg "$MSG"
}
   #+end_src

** DNSMASQ: dhcp, dns, masquerading
The macs file is actually encrypted with the following command:
#+begin_src
openssl enc -aes-256-cbc -iter 10 -salt -in SERVER-etc-dnsmasq-hosts.conf -out SERVER-etc-dnsmasq-hosts.conf.enc
#+end_src
The password is stored in other place. Please decrypt before using it. To decrypt use
#+begin_src
openssl enc -d -aes-256-cbc -iter 10 -salt -in dnsmasq-hosts.conf.enc  -out dnsmasq-hosts.conf
#+end_src
   #+name: dnsmasq_config
   #+BEGIN_SRC bash :exports code 
     # dnsmasq
     function config_dnsmasq {
	 MSG="Configuring dnsmasq. Please decrypt the dnsmasq-hosts.conf.enc file "
	 start_msg "$MSG"
	 echo "To decrypt, use : openssl enc -d -aes-256-cbc -iter 10 -in file.enc -out file.txt"
	 if [ "$TARGET" = "SERVER" ]; then
	     TFILE="/etc/dnsmasq.conf"
	     if [ x"" = x"$(grep salafisnis $TFILE 2>/dev/null)" ] || [ $FORCE -eq 1 ]; then
		 echo "Copying general config file "
		 copy_config "${BDIR}/${FDIR}/SERVER-etc-dnsmasq.conf" "$TFILE"
	     fi
	     TFILE="/etc/dnsmasq-hosts.conf"
	     if [ ! -f $TFILE ] || [ $FORCE -eq 1 ]; then
		 echo "Copying dnsmasq-hosts file "
		 copy_config "${BDIR}/${FDIR}/SERVER-etc-dnsmasq-hosts.conf" "$TFILE"
	     fi
	     TFILE="/etc/hosts"
	     if [ x"" = x"$(grep salafis $TFILE 2>/dev/null)" ] || [ $FORCE -eq 1 ]; then
		 echo "Copying hosts file "
		 copy_config "${BDIR}/${FDIR}/SERVER-etc-hosts" "$TFILE"
	     fi
	     TFILE="/etc/rc.d/rc.dnsmasq"
	     if [ x"" = x"$(grep dnsmasq.log $TFILE 2>/dev/null)" ] || [ $FORCE -eq 1 ]; then
		 echo "Copying rc.dnsmasq file "
		 copy_config "${BDIR}/${FDIR}/SERVER-etc-rc.d-rc.dnsmasq" "$TFILE"
	     fi
	     echo "Restarting services ..."
	     chmod +x /etc/rc.d/rc.dnsmasq
	     /etc/rc.d/rc.dnsmasq restart
	 else
	     echo "Not configuring on client"
	 fi
	 end_msg "$MSG"
     }
   #+END_SRC

** FIREWALL: ( also for NAT) : Arno iptables firewall.
I will use arno iptables firewall because it has worked pretty well
before . It must be installed before this step. If not installed , I
will try to use slpkg to install it.

   #+NAME: firewall_config
   #+BEGIN_SRC bash :exports code
# firewall
function config_firewall {
    MSG="installing and configuring firewall "
    if [ "$TARGET" = "SERVER" ]; then
        start_msg "$MSG"
        if $(command_exists arno-iptables-firewall) && [[ $FORCE -eq 0 ]]; then
            echo "    -> firewall already installed."
        else
            echo "Error: Package must be already installed. Exiting"
            exit 1
            # echo "Installing ... "
            # #sbopkg -e stop -B -k -i arno-iptables-firewall
            # source /root/.bashrc
            # #slpkg upgrade
            # #slpkg -s sbo arno-iptables-firewall-2.0.1e-noarch-3_SBo
            # slpkg -s sbo arno-iptables-firewall
        fi
        echo "Configuring ..."
        ln -svf /etc/rc.d/rc.arno-iptables-firewall /etc/rc.d/rc.firewall
        copy_config "${BDIR}/${FDIR}/SERVER-firewall.conf" "/etc/arno-iptables-firewall/firewall.conf"
        chmod o-rwx /etc/arno-iptables-firewall/firewall.conf
        chmod +x /etc/rc.d/rc.arno-iptables-firewall
        /etc/rc.d/rc.firewall restart
        end_msg "$MSG"
    else
        echo "Not configuring firewall on client"
    fi
    # read
}
   #+END_SRC
** NFS
   #+NAME: nfs_config
   #+BEGIN_SRC bash :exports code
# nfs
function config_nfs {
    MSG="Configuring nfs "
    start_msg "$MSG"
    if [ "$TARGET" = "SERVER" ]; then
	    #if [ $(pattern_not_present "$BASE_SERVERIP" "/etc/hosts.allow") ]; then
	    if [ x"" = x"$(grep $BASE_SERVERIP /etc/hosts.allow 2>/dev/null)" ] || [ $FORCE -eq 1 ] ; then
	        copy_config "${BDIR}/${FDIR}/SERVER-etc-hosts.allow" "/etc/hosts.allow"
	    else
            echo "hosts allow already configured"
	    fi
	    #if [ $(pattern_not_present "$SERVERIP" "/etc/exports") ]; then
	    if [ x"" = x"$(grep $BASE_SERVERIP /etc/exports 2>/dev/null)" ] || [ $FORCE -eq 1 ] ; then
	        copy_config "${BDIR}/${FDIR}/SERVER-etc-exports" "/etc/exports"
	    else
	        echo "Exports already configured. Restarting services ..."
	    fi
	    echo "NOTE: If you have NFS problems, consider editing the /etc/hosts.allow and /etc/hosts.deny files"
    else
	    bfile="/etc/fstab"
	    #if [ $(pattern_not_present "${SERVERIP}" "$bfile") ]; then
	    if [ x"" = x"$(grep ${SERVERIP} ${bfile} 2>/dev/null)" ] || [ $FORCE -eq 1 ] ; then
	        backup_file $bfile
	        echo "# NEW NEW NEW NFS stuff " >> $bfile
	        echo "${SERVERIP}:/home     /home   nfs     rw,hard,intr,usrquota  0   0" >> $bfile
	    else
	        echo "#    -> already configured"
	    fi
    fi
	chmod +x /etc/rc.d/rc.nfsd
	#/etc/rc.d/rc.nfsd restart
	#/etc/rc.d/rc.inet2 restart
    end_msg "$MSG"
}
   #+END_SRC
** SSHD
#+NAME: sshd_config
#+BEGIN_SRC bash :exports code
  # sshd
  function config_sshd {
      MSG="Configuring sshd on port 443 on server "
      start_msg "$MSG"
      if [ "$TARGET" = "SERVER" ]; then
	      if [ x"" = x"$(grep -e '^Port 443' /etc/ssh/sshd_config 2>/dev/null)" ] || [ $FORCE -eq 1 ] ; then
	      backup_file /etc/ssh/sshd_config
	      sed -i '/^#Port 22/ i ### NEW ###\nPort 22\nPort 443\nPermitRootLogin yes\nAllowGroups sshgroup root\n### NEW ###\n' /etc/ssh/sshd_config
	      echo "ClientAliveInterval 120" >> /etc/ssh/sshd_config
	      echo "ClientAliveCountMax 30" >> /etc/ssh/sshd_config
	      else
	      echo "sshd already configured"
	      fi
      else # CLIENT
	  echo "Not configuring in client. Using defaults."
      fi
	  /etc/rc.d/rc.sshd restart
      end_msg "$MSG"
  }
   #+END_SRC
** NIS
   #+NAME: nis_config
   #+BEGIN_SRC bash :exports code
# nis
function config_nis {
    MSG="Configuring nis "
    start_msg "$MSG"
    chmod +x /etc/rc.d/rc.yp
    if [ "$TARGET" = "SERVER" ]; then
	    if [ x"" = x"$(grep $BASE_SERVERIP /etc/hosts.allow  2>/dev/null)" ] || [ $FORCE -eq 1 ] ; then
	        copy_config "${BDIR}/${FDIR}/SERVER-etc-hosts.allow" "/etc/hosts.allow"
	    else
            echo "hosts allow already configured"
	    fi

        #if [ $(pattern_not_present "${NISDOMAIN}" "/etc/defaultdomain") ] ; then
	    if [ x"" = x"$(grep $NISDOMAIN /etc/defaultdomain  2>/dev/null)" ] || [ $FORCE -eq 1 ] ; then
            copy_config "${BDIR}/${FDIR}/SERVER-etc-defaultdomain" "/etc/defaultdomain"
        else
            echo "Already configured default nis domain"
        fi
        #if [ $(pattern_not_present "${NISDOMAIN}" "/etc/yp.conf") ] ; then
	    if [ x"" = x"$(grep $NISDOMAIN /etc/yp.conf  2>/dev/null)" ] || [ $FORCE -eq 1 ] ; then
            copy_config "${BDIR}/${FDIR}/SERVER-etc-yp.conf" "/etc/yp.conf"
            copy_config "${BDIR}/${FDIR}/SERVER-var-yp-Makefile" "/var/yp/Makefile"
        else
            echo "Already configured yp"
        fi
        if [ x"" = x"$(grep 'YP_SERVER_ENABLE=1' /etc/rc.d/rc.yp 2>/dev/null)" ]; then
            backup_file /etc/rc.d/rc.yp
            sed -i.bck 's/YP_CLIENT_ENABLE=.*/YP_CLIENT_ENABLE=0/ ; s/YP_SERVER_ENABLE=.*/YP_SERVER_ENABLE=1/ ;' /etc/rc.d/rc.yp
        else
            echo "Already configured as yp server"
        fi

        echo "Running nis services ..."
        ypserv
        make -BC /var/yp
        #/usr/lib64/yp/ypinit -m
    else # CLIENT
        chmod +x /etc/rc.d/rc.nfsd
        chmod +x /etc/rc.d/rc.yp
        #if [ $(pattern_not_present "${NISDOMAIN}" "/etc/defaultdomain") ]; then
	    if [ x"" = x"$(grep $NISDOMAIN /etc/defaultdomain  2>/dev/null)" ] || [ $FORCE -eq 1 ] ; then
            bfile="/etc/defaultdomain"
            backup_file $bfile
            echo ${NISDOMAIN} > $bfile
	        bfile="/etc/rc.d/rc.local"
	        backup_file $bfile
	        echo 'nisdomainname -F /etc/defaultdomain' > $bfile
            bfile="/etc/yp.conf"
            backup_file $bfile
            echo "ypserver ${SERVERIP}" > $bfile
            bfile=/etc/nsswitch.conf
            backup_file $bfile
            cp -f ${BDIR}/${FDIR}/CLIENT-nsswitch.conf $bfile
            bfile="/etc/passwd"
            backup_file $bfile
            echo +:::::: >> $bfile
            bfile="/etc/shadow"
            backup_file $bfile
            echo +:::::::: >> $bfile
            bfile="/etc/group"
            backup_file $bfile
            echo +::: >> $bfile
            if [ x"" = x"$(grep 'YP_CLIENT_ENABLE=1' /etc/rc.d/rc.yp  2>/dev/null) 2>/dev/null" ]; then
                backup_file /etc/rc.d/rc.yp
                sed -i.bck 's/YP_CLIENT_ENABLE=.*/YP_CLIENT_ENABLE=1/ ; s/YP_SERVER_ENABLE=.*/YP_SERVER_ENABLE=0/ ;' /etc/rc.d/rc.yp
            fi
            # Remove the broadcast option
            backup_file /etc/default/yp
            echo 'YPBIND_OPTS=" "' >> /etc/default/yp
        else
            echo "#    -> already configured."
        fi
    fi
    nisdomainname -F /etc/defaultdomain
    end_msg "$MSG"
}
     #+END_SRC
** TODO SHUTDOWN PERMS: Remove permissions to halt/shutdown from button and gui 
   #+name:shutdown_config
   #+begin_src sh
function config_shutdown_perms {
    MSG="Removing permissions to reboot/halt system"
    start_msg "$MSG"
    fname=disallow-power-options.rules
    if [ ! -f /etc/polkit-1/rules.d/$fname ] || [ $FORCE -eq 1 ]; then
	chmod o-x /sbin/shutdown 
	chmod o-x /sbin/halt
	cp ${BDIR}/${FDIR}/$fname /etc/polkit-1/rules.d/
    else
	echo "#    -> polkit rules already configured"
    fi

    tfname=/etc/acpi/acpi_handler.sh
    #if [ $(pattern_not_present "emoves" "$tfname") ]; then
    if [ x"" = x"$(grep emoves ${tfname}  2>/dev/null)" ] || [ $FORCE -eq 1 ] ; then
	copy_config ${BDIR}/${FDIR}/etc-acpi-acpi_handler.sh $tfname
    else
	echo "#   -> Acpi handler already configured"
    fi

    end_msg "$MSG"
}
   #+end_src
** Crontab
   This crontab reads a given script and runs it every some time
   #+name:crontab_config
   #+begin_src sh :exports code 
function config_crontab {
    MSG="Configuring crontab per minute, hour, daily, etc"
    start_msg "$MSG"
    crontab -l > /tmp/crontab
    if [ "$TARGET" = "SERVER" ]; then
	    if [ x"" = x"$(grep minute_maintenance.sh /tmp/crontab  2>/dev/null)" ] || [ $FORCE -eq 1 ] ; then
            echo "Configuring miniute maintenance ..."
	        crontab ${BDIR}/${FDIR}/SERVER-crontab -u root
	    else
	        echo "#    -> Already configured (per minute)"
	    fi
	    TNAME="/etc/cron.daily/daily_maintenance.sh"
	    if [ ! -f $TNAME ] || [ $FORCE -eq 1 ]; then
            echo "Copying daily maintenance ..."
            copy_config ${BDIR}/${FDIR}/SERVER-cron/daily_maintenance.sh "$TNAME"
	    else
            echo "#    -> Already configured (daily)"
	    fi
    else # CLIENT
	    if [ x"" = x"$(grep check_status.sh /tmp/crontab  2>/dev/null)" ] || [ $FORCE -eq 1 ] ; then
	        crontab ${BDIR}/${FDIR}/CLIENT-crontab -u root
	    else
	        echo "#    -> Already configured"
	    fi
    fi
    end_msg "$MSG"
}
   #+end_src
** PACKAGES
   Crontab will check, every hour, for two options
    1. *Recommended*: It will use ~slpkg~ to install all packages
       specified inside the file ~/home/PACKAGES.list~ . This will
       compile everything on each client, taking more time on the
       slowest, but will make sure that all clients will conform with
       their own installed libs.
    2. *Alternative, not recommended* It will install the contents
       inside the folder ~/home/PACKAGES/~ . It is assumed that home
       is exported on NFS, so all clients will see that file. Packages
       inside that folder might require dependencies also to be inside
       that folder. This is useful if one setups a package building
       server and then copy all the packages inside the named folder,
       but this assumes that all clients have the same libs installed,
       so it depends on the homogeneity of the clients.

   This uses the ~/home/PACKAGES.list~ approach read by the weekly
   cronjob to install the needed packages. Of course, it can be run
   sooner when needed.
   #+name: packages_config
   #+begin_src shell
function config_packages {
    MSG="Creating package list"
    start_msg "$MSG"
    if [ "$TARGET" = "SERVER" ]; then
	    if [ ! -f /home/PACKAGES.list ]; then
	        cat << EOF > /home/PACKAGES.list
bonnie++ arno-iptables-firewall iotop wol squid tor  autossh  parallel sshfs-fuse xfce4-xkb-plugin
dropbox ffmpeg syncthing
ganglia ganglia-web glusterfs rrdtool papi openmpi hdf5 
octave qtoctave codeblocks geany kdiff3 kile 
R grads rstudio-desktop cdo 
obs-studio ssr asciinema 
EOF
	    fi  
    fi
    end_msg "$MSG"
}
   #+end_src
** MONIT: Install and configure
Monit is a tool that allows to monitor and restart if needed
different services, files, etc. This will be another level of
redundancy (besides the scripts in crontab) to keep services
running. TODO: configure essential services on server and clients.
   #+name:monit_config
   #+begin_src sh :exports code
     function config_monit {
	 MSG="Configuring monit on server "
	 start_msg "$MSG"
	 cd "$BDIR"
	 if $(command_exists monit) && [[ $FORCE -eq 0 ]]; then
	     echo "#    -> already installed"
	 else
	     echo "ERROR: monit must be already installed. Exiting"
	     exit 1
	     # echo "Installing monit ..."
	     # source /root/.bashrc
	     # slpkg -s sbo monit
	 fi
	 echo "Configuring monit ..."
	 if [ x"" = x"$(grep -e '^include' /etc/monitrc  2>/dev/null)" ]; then
	     backup_file /etc/monitrc
	     echo 'include /etc/monit.d/*' >> /etc/monitrc
	 fi
	 chmod 0700 /etc/monitrc
	 if [ ! -d /etc/monit.d ]; then
	     mkdir /etc/monit.d
	 fi
	 if [ ! -f /usr/local/bin/monit_restart.sh ]; then
	     cat <<EOF>/usr/local/bin/monit_restart.sh
     #!/bin/env bash
     /usr/bin/date >> /var/log/restart_monit.txt
     /usr/bin/echo "$1" >> /var/log/restart_monit.txt
     /usr/bin/echo "+-------------------+" >> /var/log/restart_monit.txt
     /sbin/telinit 6
     EOF
	 fi
	 chmod +x /usr/local/bin/monit_restart.sh
	 if [ x"" = x"$(grep -e 'monit' /etc/inittab  2>/dev/null)" ]; then
	     backup_file /etc/inittab
	     echo '# Run monit in standard runlevels' >> /etc/inittab
	     echo 'mo:2345:respawn:/usr/bin/monit -Ic /etc/monitrc' >> /etc/inittab
	 fi
	 cp "${BDIR}/${FDIR}/common-monitrc" "/etc/monit.d/00-common-monitrc"
	 cp "${BDIR}/${FDIR}/${TARGET}-monitrc" "/etc/monit.d/01-${TARGET}-monitrc"
	 cp "${BDIR}/${FDIR}/HPC-monitrc" "/etc/monit.d/02-HPC-monitrc"
	 chmod +x /etc/rc.d/rc.monit
	 /etc/rc.d/rc.monit restart
	 end_msg "$MSG"
     }
   #+end_src
** CNTLM: Local proxy
This allows to create a bypassing proxy that handles all auth and
allows for computers to use  a simple proxy with no auth. For
instance, with this I can now use emacs and install packages
without much hassle.
   #+name:cntlm_config
   #+begin_src sh :exports code
function config_cntlm {
    MSG="Configuring cntlm on server "
    start_msg "$MSG"
    cd "$BDIR"
    if [ "$TARGET" = "SERVER" ]; then
        if $(command_exists cntlm) && [ $FORCE -eq 0 ]; then
            echo "#    -> already installed"
        else
            echo "Error: Package must be already installed. Exiting"
            exit 1
            # echo "Installing cntlm ..."
            # source /root/.bashrc
            # slpkg -s sbo cntlm
        fi
        echo "Configuring ..."
        chmod +x /etc/rc.d/rc.cntlm
        if [ x"" = x"$(grep $BASE_SERVERIP /etc/cntlm.conf 2>/dev/null)" ]; then
            backup_file /etc/cntlm.conf
            copy_config "${BDIR}/${FDIR}/SERVER-etc-cntlm.conf" "/etc/cntlm.conf"
            echo "Please write the password for the account to be used with cntlm"
            cntlm -H > /tmp/cntlm-hashed
            cat /tmp/cntlm-hashed >> /etc/cntlm.conf
            rm -f /tmp/cntlm-hashed
        fi
        /etc/rc.d/rc.cntlm restart
    else
        echo "Not configuring on client."
    fi
    end_msg "$MSG"
}
   #+end_src
** CLUSTER SSH: For parallel ssh
Check some tutorial at
https://www.2daygeek.com/clustershell-clush-run-commands-on-cluster-nodes-remote-system-in-parallel-linux/
#+name: clustershell
#+begin_src sh :exports code
function config_clustershell {
    MSG="Installing and configuring clustershell on server... "
    start_msg "$MSG"
    cd "$BDIR"
    if [ "$TARGET" = "SERVER" ]; then
        echo "Installing ..."
	    if $(command_exists clush) && [ $FORCE -eq 0 ]; then
	        echo "#    -> already installed"
	    else
	        source /root/.bashrc
            pip install cluster-shell
        fi
        echo "Configuring ..."
        if [ ! -d /etc/clustershell ]; then
            mkdir -p /etc/clustershell
        fi
        if [ ! -f /etc/clustershell/clush.conf ]; then
	        copy_config "${BDIR}/${FDIR}/SERVER-etc-clustershell-clush.conf" "/etc/clustershell/clush.conf"
        else
            echo "clush.conf already existing."
        fi
        if [ ! -f /etc/clustershell/groups.d/salafis.yaml ]; then
            mkdir -p /etc/clustershell/groups.d/
	        copy_config "${BDIR}/${FDIR}/SERVER-etc-clustershell-groupsd-salafis.yaml" "/etc/clustershell/groups.d/salafis.yaml"
        else
            echo "group salafis.yaml already existing".
        fi
    else
	    echo "Not configuring on client."
    fi
    end_msg "$MSG"
}
   #+end_src
** X2GOSERVER
#+name: x2go
#+begin_src shell :exports code
  function config_x2go {
      MSG="Installing and configuring x2go server "
      start_msg "$MSG"
      if [ "$TARGET" = "SERVER" ]; then
	  echo "Preconfiguring on server only ... "
	  echo "Adding x2gouser user and x2goprint group ..."
	  if [ x"" = x"$(grep x2gouser /etc/passwd 2>/dev/null)" ]; then
	      groupadd -g 290 x2gouser
	      useradd -u 290 -g 290 -c "X2Go Remote Desktop" -M -d /var/lib/x2go -s /bin/false x2gouser
	      groupadd -g 291 x2goprint
	      mkdir -p /var/spool/x2goprint &>/dev/null
	      useradd -u 291 -g 291 -c "X2Go Remote Desktop" -m -d /var/spool/x2goprint -s /bin/false x2goprint
	      chown x2goprint:x2goprint /var/spool/x2goprint
	      chmod 0770 /var/spool/x2goprint
	  else
	      echo "x2gouser already exists. Assuming x2go prerequisites is already configured"
	  fi
      else
	  if [[ x"" == x"$(grep x2godbadmin /etc/rc.d/rc.local | grep -v grep)" ]]; then
	      echo 'x2godbadmin --createdb &>/dev/null ' >> /etc/rc.d/rc.local
	  fi
      fi

      echo "Installing ..."
      if $(command_exists x2goversion) && [[ $FORCE -eq 0 ]]; then
	  echo "#    -> already installed"
      else
	  echo "Error: Package must be already installed. Exiting"
	  exit 1
	  #echo "Installing x2go ..."
	  #source /root/.bashrc
	  #slpkg -s sbo x2goserver
	  #/etc/rc.d/rc.inet2 restart
      fi
      x2godbadmin --createdb
      /etc/rc.d/rc.x2goserver start
      end_msg "$MSG"
  }
#+end_src
** ETC SKEL
Here I put some defaults for /etc/skel
#+name: skel
#+begin_src shell :exports code
function config_skel {
    MSG="Configuring /etc/skel "
    start_msg "$MSG"

    if [ "$TARGET" = "SERVER" ]; then
        echo "Configuring on server only ... "
        if [ ! -f /etc/skel/.Xauthority ]; then
            touch /etc/skel/.Xauthority
        fi
        if [ ! -f /etc/skel/.bashrc ]; then
            cat <<EOF>/etc/skel/.bashrc
export PROXY="192.168.10.1:3128"
export http_proxy="http://$PROXY"
export https_proxy="http://$PROXY"
export ftp_proxy="ftp://$PROXY"
export RSYNC_PROXY="$PROXY"

alias ls="ls --color=auto -FG "
EOF
        fi
        if [ ! -f /etc/skel/.bash_profile ]; then
            cd /etc/skel
            ln -s .bashrc .bash_profile
        fi
        if [ ! -f /etc/skel/.xinitrc ]; then
            cp /etc/X11/xinit/xinitrc.xfce /etc/skel/.xinitrc
        fi  
    else
        echo "Not configuring on client"
    fi
    
    end_msg "$MSG"
}
#+end_src
** TODO GANGLIA (needs testing)
[[http://ganglia.info/][Ganglia]] is a system used to monitor clusters. I will start using it to check the
status of the computer room. The installation is different for server and
client. I will put both here. For config see here:
https://blog.42mate.com/monitoring-your-servers-like-a-boss/
#+name: ganglia
#+begin_src shell :exports code
  function config_ganglia {
      MSG="Installing and configuring ganglia "
      start_msg "$MSG"
      cd "$BDIR"
      echo "Package must be already installed."
      # echo "Installing with slpkg ..."
      # source ~/.bashrc
      # slpkg -s sbo rrdtool
      # slpkg -s sbo confuse
      # export OPT=gmetad
      # slpkg -s sbo ganglia
      # slpkg -s sbo ganglia-web # installs the server on /var/www/htdocs/ganglia
      # unset OPT

      echo "Configuring gmond on both server and client ... "
      if [ x"" == x"$(grep clustersalafis /etc/ganglia/gmond.conf 2>/dev/null)" ] || [ $FORCE -eq 1 ] ; then
	  copy_config "${BDIR}/${FDIR}/gmond.conf" "/etc/ganglia/gmond.conf"
	  ln -s "/etc/ganglia/gmond.conf" "/etc/gmond.conf"
      else
	  echo "→ Already configured"
      fi

      if [ "$TARGET" = "SERVER" ]; then
	  echo "Configuring gmetad (ganglia monitor) on SERVER ..."
	  if [ x"" == x"$(grep clustersalafis /etc/ganglia/gmetad.conf 2>/dev/null)" ] || [ $FORCE -eq 1 ] ; then
	      copy_config "${BDIR}/${FDIR}/SERVER-gmetad.conf" "/etc/ganglia/gmetad.conf"
	  else
	      echo "-> Already configured."
	  fi
	  echo "Adding extra ganglia config to http/apache on SERVER ..."
	  TFILE="/etc/httpd/httpd.conf"
	  if [ x"" == x"$(grep ganglia.conf $TFILE 2>/dev/null)" ] || [ $FORCE -eq 1 ] ; then
	      backup_file "$TFILE"
	      sed -i 's/#Include \/etc\/httpd\/mod_php.conf/Include \/etc\/httpd\/mod_php.conf/' "$TFILE"
	      echo "Include /etc/httpd/extra/ganglia.conf" >> "$TFILE"
	  else
	      echo "-> Already configured."
	  fi
	  echo "Copying extra ganglia config on SERVER ..."
	  TFILE="/etc/httpd/extra/ganglia.conf"
	  if [ ! -f "$TFILE" ]; then
	      copy_config "${BDIR}/${FDIR}/SERVER-etc-httpd-extra-ganglia.conf" "$TFILE"
	  fi
	  chmod +x /etc/rc.d/rc.httpd
	  chmod +x /etc/rc.d/rc.gmetad
	  /etc/rc.d/rc.httpd restart
	  /etc/rc.d/rc.gmetad restart
	  ln -sf /etc/ganglia/gmetad.conf /etc/
      fi
      ln -sf /etc/ganglia/gmond.conf /etc/
      chmod +x /etc/rc.d/rc.gmond
      /etc/rc.d/rc.gmond restart
      echo "Done"
      end_msg "$MSG"
  }
#+end_src
** TODO NETDATA (needs testing)
NETDATA is an alternative to ganglia and is very simple to configure and gets a
lot of metrics. See: https://www.netdata.cloud/

I had to modify the slackbuild to include some commands for the correct
installation of the static libs mosquitto and libwebsocket. Here I will put the
modified slackbuild.

*** Configuration files
- slackbuild including calls for building mosquitto and libws
#+begin_src shell :tangle files/netdata.SlackBuild
#!/bin/sh

# Slackware build script for netdata

# Copyright 2017-2019 Willy Sudiarto Raharjo <willysr@slackbuilds.org>
# All rights reserved.
#
# Redistribution and use of this script, with or without modification, is
# permitted provided that the following conditions are met:
#
# 1. Redistributions of this script must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
#  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
#  EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
#  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
#  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
#  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
#  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
#  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

PRGNAM=netdata
VERSION=${VERSION:-1.29.3}
BUILD=${BUILD:-1}
TAG=${TAG:-_SBo}

NETDATA_USER=${NETDATA_USER:-netdata}
NETDATA_UID=${NETDATA_UID:-338}
NETDATA_GROUP=${NETDATA_GROUP:-netdata}
NETDATA_GID=${NETDATA_GID:-338}

if [ -z "$ARCH" ]; then
  case "$( uname -m )" in
    i?86) ARCH=i586 ;;
    arm*) ARCH=arm ;;
       ,*) ARCH=$( uname -m ) ;;
  esac
fi

bailout() {
  echo "  You must have a $NETDATA_USER user and $NETDATA_GROUP group to run this script. "
  echo "    # groupadd -g $NETDATA_GID $NETDATA_GROUP "
  echo "    # useradd -u $NETDATA_UID -g $NETDATA_GID -c \"netdata user\" -s /bin/bash $NETDATA_USER "
  exit 1
}

# Bail if user and/or group isn't valid on your system
if ! grep -q "^$NETDATA_USER:" /etc/passwd; then
  bailout
elif ! grep -q "^$NETDATA_GROUP:" /etc/group; then
  bailout
fi

CWD=$(pwd)
TMP=${TMP:-/tmp/SBo}
PKG=$TMP/package-$PRGNAM
OUTPUT=${OUTPUT:-/tmp}

if [ "$ARCH" = "i586" ]; then
  SLKCFLAGS="-O2 -march=i586 -mtune=i686"
  LIBDIRSUFFIX=""
elif [ "$ARCH" = "i686" ]; then
  SLKCFLAGS="-O2 -march=i686 -mtune=i686"
  LIBDIRSUFFIX=""
elif [ "$ARCH" = "x86_64" ]; then
  SLKCFLAGS="-O2 -fPIC"
  LIBDIRSUFFIX="64"
else
  SLKCFLAGS="-O2"
  LIBDIRSUFFIX=""
fi

set -e

rm -rf $PKG
mkdir -p $TMP $PKG $OUTPUT
cd $TMP
rm -rf $PRGNAM-$VERSION
tar xvf $CWD/$PRGNAM-$VERSION.tar.gz
cd $PRGNAM-$VERSION
chown -R root:root .
find -L . \
 \( -perm 777 -o -perm 775 -o -perm 750 -o -perm 711 -o -perm 555 \
  -o -perm 511 \) -exec chmod 755 {} \; -o \
 \( -perm 666 -o -perm 664 -o -perm 640 -o -perm 600 -o -perm 444 \
  -o -perm 440 -o -perm 400 \) -exec chmod 644 {} \;

#########################################
# NEW NEW NEW NEW
bash packaging/bundle-mosquitto.sh ./
bash packaging/bundle-lws.sh ./
#########################################

autoreconf -fiv
CFLAGS="$SLKCFLAGS" \
CXXFLAGS="$SLKCFLAGS" \
./configure \
  --prefix=/usr \
  --libdir=/usr/lib${LIBDIRSUFFIX} \
  --sysconfdir=/etc \
  --localstatedir=/var \
  --mandir=/usr/man \
  --docdir=/usr/doc/$PRGNAM-$VERSION \
  --with-user=$NETDATA_USER \
  --with-zlib \
  --with-math \
  --build=$ARCH-slackware-linux \
  --with-bundled-lws=./externaldeps/libwebsockets/
# LAST LINE IS NEW

make
make install DESTDIR=$PKG

find $PKG -print0 | xargs -0 file | grep -e "executable" -e "shared object" | grep ELF \
  | cut -f 1 -d : | xargs strip --strip-unneeded 2> /dev/null || true

mkdir -p $PKG/usr/doc/$PRGNAM-$VERSION
cp -a LICENSE *.md $PKG/usr/doc/$PRGNAM-$VERSION
cat $CWD/$PRGNAM.SlackBuild > $PKG/usr/doc/$PRGNAM-$VERSION/$PRGNAM.SlackBuild

mkdir -p $PKG/var/lock/subsys/ $PKG/var/cache/netdata $PKG/var/lib/netdata $PKG/var/log/netdata

# set permission
chown -R $NETDATA_USER:$NETDATA_GROUP $PKG/var/lib/netdata
chown -R $NETDATA_USER:$NETDATA_GROUP $PKG/var/log/netdata
chown -R $NETDATA_USER:$NETDATA_GROUP $PKG/var/cache/netdata
chown -R $NETDATA_USER:$NETDATA_GROUP $PKG/usr/share/netdata/web
chown -R $NETDATA_USER:$NETDATA_GROUP $PKG/etc/netdata

mkdir -p $PKG/etc/rc.d/
install -m 0644 $CWD/rc.netdata $PKG/etc/rc.d/

# handle all conf files
touch $PKG/etc/netdata/netdata.conf.new

for L in `ls $PKG/usr/lib${LIBDIRSUFFIX}/netdata/conf.d/*.conf`
do
mv $L $L.new
done

for L in `ls $PKG/usr/lib${LIBDIRSUFFIX}/netdata/conf.d/python.d/*.conf`
do
mv $L $L.new
done

for L in `ls $PKG/usr/lib${LIBDIRSUFFIX}/netdata/conf.d/charts.d/*.conf`
do
mv $L $L.new
done

for L in `ls $PKG/usr/lib${LIBDIRSUFFIX}/netdata/conf.d/health.d/*.conf`
do
mv $L $L.new
done

#for L in `ls $PKG/usr/lib${LIBDIRSUFFIX}/netdata/conf.d/node.d/*.conf`
#do
#mv $L $L.new
#done

for L in `ls $PKG/usr/lib${LIBDIRSUFFIX}/netdata/conf.d/statsd.d/*.conf`
do
mv $L $L.new
done

mkdir -p $PKG/install
cat $CWD/slack-desc > $PKG/install/slack-desc
sed -e s/%LIBDIRSUFFIX%/$LIBDIRSUFFIX/g $CWD/doinst.sh > $PKG/install/doinst.sh

cd $PKG
/sbin/makepkg -l y -c n $OUTPUT/$PRGNAM-$VERSION-$ARCH-$BUILD$TAG.${PKGTYPE:-tgz}

#+end_src
- Configuration for the proxy
  #+begin_src conf :tangle files/etc-netdata-netdata.conf
[cloud]
    proxy = 192.168.10.1:3128
    
  #+end_src
*** Install and Configuration Scripts
#+name: netdata
#+begin_src shell :exports code
  function config_netdata {
      MSG="Installing and configuring netdata "
      start_msg "$MSG"
      cd "$BDIR"
      echo "Installation"
      if $(command_exists netdata); then
	  echo "-> Already installed"
      else
	  echo "Package must be already installed. Exiting"
	  exit 1
	  # source ~/.bashrc
	  # echo "Installing deps ..."
	  # slpkg -s sbo libuv uuid mongo-c-driver PyYAML
	  # slpkg -s slack lz4
	  # echo "Installing netdata with modified slackbuild ..."
	  # cd /tmp
	  # wget https://slackbuilds.org/slackbuilds/14.2/system/netdata.tar.gz &&
	  # wget https://github.com/netdata/netdata/archive/v1.29.3/netdata-1.29.3.tar.gz &&
	  # tar xf netdata.tar.gz &&
	  # mv netdata/netdata.SlackBuild{,-orig} &&
	  # cp ${BDIR}/${FDIR}/netdata.SlackBuild netdata/ &&
	  # chmod +x netdata/netdata.SlackBuild &&
	  # tar czf netdata.tar.gz netdata &&
	  # slpkg -a netdata.tar.gz netdata-1.29.3.tar.gz &&
	  # chmod +x /etc/rc.d/rc.netdata
      fi
      if [ "$TARGET" = "SERVER" ]; then
	  groupadd -g 338 netdata 2>/dev/null
	  useradd -u 338 -g 338 -c "netdata user" -s /bin/bash netdata 2>/dev/null
      fi

      echo "Configuring proxy on both server and client ... "
      if [ x"" == x"$(grep 192.168.10.1 /etc/netdata/netdata.conf 2>/dev/null)" ] || [ $FORCE -eq 1 ] ; then
	  copy_config "${BDIR}/${FDIR}/etc-netdata-netdata.conf" "/etc/netdata/netdata.conf"
      else
	  echo "-> Already configured"
      fi

      chmod +x /etc/rc.d/rc.netdata
      /etc/rc.d/rc.netdata restart
      echo "Done"
      end_msg "$MSG"
  }
#+end_src

#+RESULTS: netdata

TODO TODO TODO
This is the modern way to install it. Maybe install it when configuring the client/server, and claim it when they are already running
#+begin_src shell :tangle install_netdata.sh
   # install in opt: needs new config to be monitored by monit (using procmath)
   wget -O ./kickstart.sh https://my-netdata.io/kickstart.sh && sh ./kickstart.sh --non-interactive --require-cloud
   cp "/root/repos/computer-labs/computer-room/files/etc-netdata-netdata.conf" "/opt/netdata//etc/netdata/netdata.conf"
#+end_src

#+begin_src shell
  # claim node
wget -O ./kickstart.sh https://my-netdata.io/kickstart.sh && sh ./kickstart.sh --claim-token TOKEN --claim-rooms ROOMID --claim-url https://app.netdata.cloud
#+end_src

** Wake on lan
#+NAME: wol_config
#+BEGIN_SRC bash :exports code
# wol
function config_wol {
    MSG="Configuring wake on lan"
    start_msg "$MSG"
    if [ x"" = x"$(grep -e 'wol' /etc/rc.d/rc.local 2>/dev/null)" ] || [ $FORCE -eq 1 ] ; then
        cat<<EOF>> /etc/rc.d/rc.local
echo "Setting Wake-on-LAN to Enabled"
/usr/sbin/ethtool -s eth0 wol pubmg || /usr/sbin/ethtool -s eth0 wol g 
EOF
    else
        echo "  -> Already configured in rc.local"
    fi    
    end_msg "$MSG"
}
   #+END_SRC
**
** RPC bind
#+NAME: rpcbind_config
#+BEGIN_SRC bash :exports code
  # rpcbind
  function config_rpcbind {
      MSG="Configuring rpcbind to reduce logging noise"
      start_msg "$MSG"
      sed -i.bck 's/rpcbind -l/rpcbind/' /etc/rc.d/rc.rpc
      end_msg "$MSG"
  }
   #+END_SRC
**
** TODO Quota
   Todo means that this is not included in config yet, but scripts are working
       #+begin_src shell :tangle setup_quota.sh
# Refs
# - https://gehrcke.de/2013/05/setting-up-quotas-on-a-local-linux-file-system/
# - https://wwwphy.princeton.edu//cluster/admin/tasks/nfs.html
# - https://wiki.archlinux.org/title/disk_quota
echo "Check that =/etc/hosts.allow= hast =rquotad= "
if ! grep -q 'rquotad' /etc/hosts.allow; then
    echo "'rquotad' : 192.168.10.0/255.255.255.0 : allow" >> /etc/hosts.allow
else
    echo "Already done."
fi      

echo "Create needed files"
if [[ ! -f /home/aquota.user ]]; then
    touch /home/aquota.user
    chmod 600 /home/aquota.*
else    
    echo "Already done."
fi  
    
echo "Fix home mount options ..."
if ! grep -q home /etc/fstab | grep -q usrjquota; then
    awk '{if ($2=="/home") print $1,$2,$3,$4",usrjquota=aquota.user,jqfmt=vfsv1",$5,$6}' /etc/fstab;
else
    echo "Already done."
fi
mount -o remount /home

echo "Activating quota"
quotaon -avug

echo "Adding quotacheck to /etc/rc.d/rc.local"
if ! grep -q quotachek /etc/rc.d/rc.local; then
    echo 'echo "Checking quota ..."' >> /etc/rc.d/rc.local
    echo "/usr/sbin/quotacheck -vug /home &" >> /etc/rc.d/rc.local
else
    echo "Already done"
fi    

echo "Make sure that all nfs clients mount the filesystem as"
echo "${SERVERIP}:/home     /home   nfs     rw,hard,intr,usrquota  0   0"

echo "Useful command: repquota /home"
    #+end_src
** Write final script
#+BEGIN_SRC bash :exports code :noweb yes :tangle scripts/bootstrap_slackware_computer_room.sh :tangle-mode (identity #o444)
  #!/bin/bash

  # NOTE: The original base file is in the config_computer_room.org file
  # Color stuff based on: https://devdojo.com/bobbyiliev/how-to-create-an-interactive-menu-in-bash#testing-the-script

  SCRIPTS_DIR=$HOME/repos/computer-labs/computer-room/scripts
  CONFIG=${CONFIG:-computer_room.conf}

  if [ ! -f $CONFIG ]; then
      echo "ERROR: Config file not found -> $CONFIG"
      exit 1
  fi
  source $CONFIG
  source $SCRIPTS_DIR/util_functions.sh

  # check args
  if [ "$#" -ne "2" ]; then usage; exit 1 ; fi
  if [ ! -d "$1" ]; then echo "Dir does not exist : $1"; usage; exit 1 ; fi
  if [  "$2" != "SERVER" ] && [ "$2" != "CLIENT" ]; then usage; exit 1 ; fi

  TARGET="$2"
  # global vars
  BDIR=$PWD
  FDIR=$1
  LINUX="SLACKWARE"

  ##
  # Color  Variables
  ##
  red='\e[31m'
  green='\e[32m'
  yellow='\e[33m'
  blue='\e[34m'
  magenta='\e[35m'
  cyan='\e[36m'
  lred='\e[91m'
  lgreen='\e[92m'
  lyellow='\e[93m'
  lblue='\e[94m'
  lmagenta='\e[95m'
  lcyan='\e[96m'
  white='\e[97m'
  clear='\e[0m'

  ##
  # Color Functions
  ##

  ColorGreen(){
	  echo -ne $green$1$clear
  }
  ColorLGreen(){
	  echo -ne $lgreen$1$clear
  }
  ColorBlue(){
	  echo -ne $blue$1$clear
  }
  ColorCyan(){
	  echo -ne $cyan$1$clear
  }
  ColorYellow(){
	  echo -ne $yellow$1$clear
  }

  echo "###############################################"
  echo "# Configuring $TARGET ..."
  if [[ $FORCE -eq 1 ]]; then
      echo "# Forcing configuration ...";
  fi
  echo "###############################################"

  <<proxy_config>>

  <<nic_config>>

  <<ntp_config>>

  <<dnsmasq_config>>

  <<firewall_config>>

  <<nfs_config>>

  <<nis_config>>

  <<monit_config>>

  <<shutdown_config>>

  <<crontab_config>>

  <<packages_config>>

  <<sshd_config>>

  <<cntlm_config>>

  <<x2go>>

  <<clustershell>>

  <<skel>>

  <<ganglia>>

  <<netdata>>

  <<wol_config>>
	
  <<rpcbind_config>>

  # Call all functions
  all ()
  {
      config_ntp
      config_dnsmasq
      config_nfs
      config_nis
      config_shutdown_perms
      config_crontab
      config_packages
      config_sshd
      config_x2go
      config_clustershell
      config_monit
      config_skel
      config_ganglia
      config_netdata
      config_firewall
      config_cntlm
      config_network
      config_proxy
      config_wol
      config_rpcbind
  }

  ##################################
  # check env vars and configure accordingly
  ##################################
  if [[ ($ALL == 1) ]]; then ColorCyan 'Configuring ALL'; all; fi
  if [[ ($PROXY == 1) ]]; then ColorCyan 'Configuring Proxy'; config_proxy; fi
  if [[ ($NETWORK == 1) ]]; then ColorCyan 'Configuring Network'; config_network; fi
  if [[ ($NTP == 1) ]]; then ColorCyan 'Configuring ntp'; config_ntp; fi
  if [[ ($DNSMASQ == 1) ]]; then ColorCyan 'Configuring dnsmasq'; config_dnsmasq; fi
  if [[ ($FIREWALL == 1) ]]; then ColorCyan 'Configuring firewall'; config_firewall; fi
  if [[ ($NFS == 1) ]]; then ColorCyan 'Configuring nfs'; config_nfs; fi
  if [[ ($NIS == 1) ]]; then ColorCyan 'Configuring nis'; config_nis; fi
  if [[ ($SHUTDOWN_PERMS == 1) ]]; then ColorCyan 'Configuring shutdown perms'; config_shutdown_perms; fi
  if [[ ($CRONTAB == 1) ]]; then ColorCyan 'Configuring crontab'; config_crontab; fi
  if [[ ($PACKAGES == 1) ]]; then ColorCyan 'Configuring packages'; config_packages; fi
  if [[ ($CNTLM == 1) ]]; then ColorCyan 'Configuring cntlm'; config_cntlm; fi
  if [[ ($SSHD == 1) ]]; then ColorCyan 'Configuring sshd'; config_sshd; fi
  if [[ ($X2GO == 1) ]]; then ColorCyan 'Configuring x2go'; config_x2go; fi
  if [[ ($CLUSTERSHELL == 1) ]]; then ColorCyan 'Configuring clustershell'; config_clustershell; fi
  if [[ ($MONIT == 1) ]]; then ColorCyan 'Configuring monit'; config_monit; fi
  if [[ ($SKEL == 1) ]]; then ColorCyan 'Configuring skel'; config_skel; fi
  if [[ ($GANGLIA == 1) ]]; then ColorCyan 'Configuring ganglia'; config_ganglia; fi
  if [[ ($NETDATA == 1) ]]; then ColorCyan 'Configuring netdata'; config_netdata; fi
  if [[ ($WOL == 1) ]]; then ColorCyan 'Configuring wake on lan'; config_wol; fi
  if [[ ($RPCBIND == 1) ]]; then ColorCyan 'Configuring rpcbind'; config_rpcbind; fi

  ##################################
  # use an interactive menu
  ##################################
  #menu(){
  #echo -ne "
  #Services to configure on: $TARGET
  # $(ColorGreen '1)') proxy
  # $(ColorGreen '2)') network (rc.inet1.conf)
  # $(ColorGreen '3)') ntp
  # $(ColorGreen '4)') dnsmasq
  # $(ColorGreen '5)') firewall
  # $(ColorGreen '6)') nfs
  # $(ColorGreen '7)') nis
  # $(ColorGreen '8)') clustershell
  # $(ColorGreen '9)') x2go
  # $(ColorGreen '10)') shutdown perms
  # $(ColorGreen '11)') crontab
  # $(ColorGreen '12)') packages
  # $(ColorGreen '13)') cntlm
  # $(ColorGreen '14)') sshd
  # $(ColorGreen '15)') monit (depends on already configured cntlm, x2g0, sshd)
  # $(ColorLGreen '16)') /etc/skel
  # $(ColorLGreen '17)') ganglia
  # $(ColorLGreen '18)') netdata
  # $(ColorLGreen '19)') wol
  # $(ColorLGreen '20)') Configure ALL
  # $(ColorYellow '0)') Exit
  # $(ColorCyan 'Choose an option:') "
  #         read a
  #         case $a in
  # 	        1) config_proxy ; menu ;;
  # 	        2) config_network ; menu ;;
  # 	        3) config_ntp ; menu ;;
  # 	        4) config_dnsmasq ; menu ;;
  # 	        5) config_firewall ; menu ;;
  # 	        6) config_nfs ; menu ;;
  # 	        7) config_nis ; menu ;;
  # 	        8) config_clustershell ; menu ;;
  # 	        9) config_x2go ; menu ;;
  # 	        10) config_shutdown_perms ; menu ;;
  # 	        11) config_crontab ; menu ;;
  # 	        12) config_packages ; menu ;;
  # 	        13) config_cntlm ; menu ;;
  # 	        14) config_sshd ; menu ;;
  # 	        15) config_monit ; menu ;;
  # 	        16) config_skel ; menu ;;
  # 	        17) config_ganglia ; menu ;;
  # 	        18) config_netdata ; menu ;;
  # 	        19) config_wol ; menu ;;
  # 	        20) all ; menu ;;
  # 		0) exit 0 ;;
  # 		*) echo -e $lred"Wrong option: $a"$clear; exit 1;;
  #         esac
  # }
  # menu

  # run services (better done on script that keeps the system up, when the client is on the network)
  #/etc/rc.d/rc.nfsd restart
  #mount -a
  #/etc/rc.d/rc.yp restart
  #/etc/rc.d/rc.inet2 restart
  #rpcinfo -p localhost


#+END_SRC

** DEPRECATED
*** pssh: Already installed, use the following links to fix the password
   - https://unix.stackexchange.com/questions/128974/parallel-ssh-with-passphrase-protected-ssh-key
   - https://www.funtoo.org/Keychain
   - https://stackoverflow.com/questions/43597283/pass-the-password-as-an-argument-in-pssh
   - https://www.golinuxcloud.com/pssh-public-key-authentication-passwordless/

*** Client: Copy public id for password-less access and allow root login
   #+name:publicid_config
   #+begin_src sh
function config_publicid_sshpassword {
    if [ "$TARGET" = "CLIENT" ]; then
	MSG="Copying server public key  to configure passwordless access for root"
	start_msg "$MSG"
	mkdir -p /root/.ssh &>/dev/null
	#if [ $(pattern_not_present "${SERVER_DOMAINNAME}" "/root/.ssh/authorized_keys") ]; then
	if [ x"" == x"$(grep $SERVER_DOMAINNAME /root/.ssh/authorized_keys  2>/dev/null)" ] || [ $FORCE -eq 1 ] ; then
	    cat ${BDIR}/${FDIR}/CLIENT-server_id_rsa.pub >> /root/.ssh/authorized_keys
	    chmod 700 /root/.ssh
	    chmod 640 /root/.ssh/authorized_keys
	else
	    echo "#    -> already configured"
	fi
	end_msg "$MSG"

	MSG="Allowing root login for client"
	start_msg "$MSG"
	bfile="/etc/ssh/sshd_config"
	if [ x"" == x"$(grep '^PermitRootLogin.*yes' $bfile  2>/dev/null)" ] || [ $FORCE -eq 1 ] ; then
	    backup_file $bfile
	    echo "PermitRootLogin yes" >> $bfile
	    /etc/rc.d/rc.sshd restart
	else
	    echo "#    -> already_configured"
	fi
	end_msg "$MSG"
    fi

}
   #+end_src
* Auxiliary scripts
** Update slackware patches/packages on clients
   Notice that =slackpkg upgrade patches= only works on stable, for
   current you need =upgrade-all=. 
   #+begin_src shell
     clush -P -b -w @roles:nodes "source .bashrc; printf 'YES\n' | slackpkg update gpg"
     clush -P -b -w @roles:nodes "source .bashrc; printf 'Y\n' | slackpkg update"
     clush -P -b -w @soles:nodes "source .bashrc; slackpkg -batch=on -default_answer=y upgradea-all"
   #+end_src
** Create an user
  #+BEGIN_SRC sh :exports code :mkdirp yes :tangle scripts/create_user.sh 
#!/bin/bash                                                                                                               
if [ x"" != x"$1" ]; then
	adduser $1
	usermod -a -G audio,cdrom,floppy,plugdev,video,power,netdev,lp,scanner $1
	make -BC /var/yp
	#su - $1                                                                                                              
	#xwmconfig                                                                                                            
else
	echo "Error. Debes llamar este script como:"
	echo "bash $0 nombredeusuarionuevo"
fi

  #+END_SRC
   
** Create users from csv list with usernames and ids
This script reads a list of usernames and passwords and creates the
corresponding users
#+begin_src sh :exports code :tangle scripts/create_users_from_list.sh :tangle-mode (identity #o444)
#!/bin/bash

# This script creates users according to a list of usernames and passwords
# The file must be
# username1 password1 more info
# username2 password2 more info

# Please review the groups. The sshgroup allows for ssh connections to the server

FNAME=${1}
if [ ! -f $FNAME ]; then
    echo "Error: filename $FNAME does not exists"
    exit 1
fi

while read line
do
    username=$(echo $line | awk '{print $1}')
    password=$(echo $line | awk '{print $2}')
    echo username=$username
    echo password=$password
    # echo "Deleting account $username"
    # userdel $username
    echo Creating account $username
    useradd -d /home/$username -G audio,cdrom,floppy,plugdev,video,netdev,lp,scanner,sshgroup  -m -s /bin/bash $username
    echo "Changing password for $username to ${password}"
    echo ${username}:${password} | chpasswd
    # make the password expire to force changing it on first login
    chage -d0 ${username}
    #echo "Recursive chown ... &"
    #chown -R $username.$username /home/$username &
done < $FNAME

#read

echo "Updating nis database"
make -C /var/yp/
#service portmap restart
#service ypserv  restart
/etc/rc.d/rc.inet2 restart
echo "DONE."
   #+end_src
** Check and delete inactive users
   - Find inactive users
     #+BEGIN_SRC sh :exports code :tangle scripts/get_inactive.sh
DAYS=180
OFILE=/root/inactive_users.txt
echo > $OFILE
for dname in /home/*; do 
    if [ -d $dname ]; then 
	result=$(find "${dname}" -mtime -${DAYS} -type f -print -quit)
	if [[ $result == "" ]]; then
	    echo "User home has been inactive for more than ${DAYS} days : $dname"
	    echo "${dname#/home/}" >> $OFILE
	fi
    fi
done
echo "###########################################"
echo "Inactive users wrote to $OFILE"
      
     #+END_SRC
   - Delete inactive users
     #+BEGIN_SRC  sh :exports code :tangle scripts/del_inactive.sh
for a in $(cat /root/inactive_users.txt); do
    if [ "$a" == "ramezquitao" ] || [ "$a" == "ersanchezp" ] || [ "$a" == "jdmunozc" ] || [ "$a" == "jbaena" ] || [ "$a" == "oquendo" ]; then
        echo "skipping account : $a"
        continue
    fi
    echo "deleting $a"
    userdel -rf $a;
done
     #+END_SRC
** User disk usage
   #+BEGIN_SRC sh :exports code :mkdirp yes :tangle scripts/user_disk_usage.sh
      echo "Computing user disk usage ... "
      for a in /home/*; do 
	  du -sh $a ; 
      done | sort -rh > user_disk_usage.txt
      echo "################################"
      echo "DONE: results sorted and wrote to user_disk_usage.txt"

   #+END_SRC
** Recreate users from folders inside home
   This is useful when the server was reinstalled
   #+begin_src sh :exports code :tangle scripts/recreate_users_from_directories.sh :tangle-mode (identity #o444)
#!/bin/bash

for usernamedir in /home/*; do 
    if [ -d $usernamedir ]; then
	username=$(basename $usernamedir)
	if [ "ftp" != "$username" ] && [ "localuser" != "$username" ] ; then 
	    #echo "Deleting account $username"
	    #userdel $username
	    echo Creating account $username
	    useradd -d /home/$username -G audio,cdrom,floppy,plugdev,video -m -s /bin/bash $username
	    echo "Changing password for $username to ${username}123"
	    echo ${username}:${username}123 | chpasswd 
	    echo "Recursive chown ... &"
	    chown -R $username.$username /home/$username & 
	fi
    fi
done
echo "Updating nis database"
make -C /var/yp/
service portmap restart
service ypserv  restart

echo "DONE."

   #+end_src
** Data dir for users
In case there are some hard disk space to share between users,
create directories for each one
   #+begin_src sh  :exports code :tangle scripts/create_data_dirs_for_users.sh :tangle-mode (identity #o444)
#!/bin/bash

for a in /home/*; do
    bname=$(basename $a)
    id -u $bname &> /dev/null
    status=$?
    #echo $bname
    #echo $status
    if [[ "0" -eq "$status" ]]; then
	for b in data01 data02; do
	    mkdir -p /mnt/local/$b/$bname	    
	    chown -R $bname.$bname /mnt/local/$b/$bname
	done
    fi
done
   #+end_src

** Burn slackware live
  - live
    #+BEGIN_SRC sh :tangle scripts/burn_slackware_live.sh
USBKEYS=($(
    grep -Hv ^0$ /sys/block/*/removable |
    sed s/removable:.*$/device\\/uevent/ |
    xargs grep -H ^DRIVER=sd |
    sed s/device.uevent.*$/size/ |
    xargs grep -Hv ^0$ |
    cut -d / -f 4
))

echo "Burning slackware image iso to /dev/sd{b,c,d,e,f,g,h} -> ${USBKEYS[*]}"
parallel --gnu "dd if=/root/dev-iso/slackware64-live-current.iso of=/dev/{} " ::: ${USBKEYS[*]}
if [ "$?" == "0" ]; then
    sync
    echo "Done. Please test the usb on another computer"
else
    echo "Some error ocurred. Exiting."
fi
    #+END_SRC
  - With persistence
    #+BEGIN_SRC sh :tangle scripts/burn_slackware_live_persistence.sh
USBKEYS=($(
    grep -Hv ^0$ /sys/block/*/removable |
    sed s/removable:.*$/device\\/uevent/ |
    xargs grep -H ^DRIVER=sd |
    sed s/device.uevent.*$/size/ |
    xargs grep -Hv ^0$ |
    cut -d / -f 4
))
echo "Burning slackware image iso with persistence to /dev/sd{b,c,d,e,f,g,h} -> ${USBKEYS[*]}"
#parallel --gnu bash /root/dev-iso/liveslak/iso2usb.sh -i /root/dev-iso/slackware64-live-current.iso -o /dev/{} -u -v -w 30  ::: ${USBKEYS[*]}
bash /root/dev-iso/liveslak/iso2usb.sh -i /root/dev-iso/slackware64-live-current.iso -o /dev/${USBKEYS[0]} -u -v -w 30
if [ "$?" == "0" ]; then
    echo "Done. SYncing writing ... "
    sync
    echo "Done. Please test the usb on another computer"
else
    echo "Some error ocurred. Exiting."
fi
    #+END_SRC
** Peformance monitor
  #+BEGIN_SRC sh :exports code :tangle scripts/monitor_perf.sh
    TOTALITER=10800
    iotop -botq --iter=$TOTALITER &>> /tmp/log-iotop
    top -b -n $TOTALITER &>> /tmp/log-top
    /usr/local/sbin/iftop -P -b -i eth0 -t &>> /tmp/log-iftop-eth0
    /usr/local/sbin/iftop -P -b -i eth0 -t &>> /tmp/log-iftop-eth1

    vmstat -a -t 1 $TOTALITER &>> /tmp/log-vmstat
    vmstat -s -t 1 $TOTALITER &>> /tmp/log-vmstat-s
    vmstat -D -t 1 $TOTALITER &>> /tmp/log-vmstat-D

    function runiostat {
	while  [ 1 ]; do
	    sleep 1
	    iostat >> /tmp/log-iostat
    }

    runiostat
  #+END_SRC

** Update patches
#+begin_src shell :tangle scripts/update_patches.sh
alias psshn="pssh -i -A  -h /home/oquendo/MYHOSTS  -O StrictHostKeyChecking=no -O UserKnownHostsFile=/dev/null  -O  GlobalKnownHostsFile=/dev/null"

#psshn 'echo "check_certificate = off" > /root/.wgetrc'
#psshn 'source /root/.bashrc ; slackpkg -batch=on -default_answer=y update '
##psshn 'killall -9 slackpkg; rm -f /var/lock/slackpkg.* '
#psshn 'source /root/.bashrc ; slackpkg -batch=on -default_answer=y upgrade patches'

psshn 'source /root/.bashrc; slpkg upgrade'
psshn "source /root/.bashrc; slpkg -s slack '' --patches"


#+end_src
** Hardware sala
   #+begin_src
#clush -P -b -w @roles:TEST 'free -h --giga | grep Mem | tr -s " " | cut -d " " -f 2'
#clush -P -b -w @roles:TEST 'cat /proc/cpuinfo | grep "model name" | head -n 1 | sed "s/Intel(R) Core(TM)/Intel/" | sed "s/ CPU @//"'
#clush -P -b -w @roles:TEST 'df -h -l --total | grep total | tr -s " " | cut -f 2 -d " "'
#clush -P -b -w @roles:TEST '/sbin/ifconfig | grep ether | tr -s " " | cut -f 3 -d " "'

#clush -P -b -w @roles:TEST 'free -h --giga | grep Mem | tr -s " " | cut -d " " -f 2; cat /proc/cpuinfo | grep "model name" | head -n 1 | sed "s/Intel(R) Core(TM)/Intel/" | sed "s/ CPU @//";df -h -l --total | grep total | tr -s " " | cut -f 2 -d " "; /sbin/ifconfig | grep ether | tr -s " " | cut -f 3 -d " "'

clush -P -b -w @roles:TEST 'cat /proc/cpuinfo | grep "model name" | head -n 1 | cut -d ":" -f2 | sed "s/(R)//;s/Core(TM) //;s/CPU @ //;s/Core(TM)2//;s/ Duo CPU //"; free -h --giga | grep Mem | tr -s " " | cut -d " " -f 2; df -h -l --total | grep total | tr -s " " | cut -f 2 -d " "; /sbin/ifconfig | grep ether | tr -s " " | cut -f 3 -d " "'
   #+end_src
** Fix virtualbox gui
   #+begin_src shell
VBoxManage setextradata global GUI/UpdateDate never
   #+end_src shell
** Clush example
   #+begin_src shell
clush -P -b  -w @roles:8thr 'date' 
   #+end_src
** Check virtualization
   #+begin_src shell
     echo "Checking if AMD-V / VT-X is enabled in the BIOS/UEFI: "
     if systool -m kvm_amd -v &> /dev/null || systool -m kvm_intel -v &> /dev/null ; then
	 echo "TRUE";
     else
	 echo "FALSE";
     fi
   #+end_src
** Bandwidth exploring
   The following mpi program alows to compute the bandwidth between pair of ocmputers
   #+begin_src cpp :tangle bw.cpp
     #include "mpi.h"
     #include <iostream>
     #include <cstdlib>

     void bandwidth(int reps, int size, int pid, int np);

     int main(int argc, char **argv)
     {
       /* MPI Variables */
       int np, pid;

       /* MPI setup */
       MPI_Init(&argc, &argv);
       MPI_Comm_size(MPI_COMM_WORLD, &np);
       MPI_Comm_rank(MPI_COMM_WORLD, &pid);

       const int REPS = std::atoi(argv[1]);  
       const int SIZE = std::atoi(argv[2]);  
       bandwidth(REPS, SIZE, pid, np);

       /* finish */
       MPI_Finalize();

       return 0;
     }

     void bandwidth(int reps, int size, int pid, int np)
     {
       MPI_Status status;
       int tag = 0;
       double * buffer = new double [size]{1};
       for(int ii = 0; ii < reps; ++ii) {
	 if (0 == pid) { /* Master */
	   double tstart = MPI_Wtime();
	   MPI_Send(&buffer[0], size, MPI_DOUBLE, 1, tag, MPI_COMM_WORLD);
	   MPI_Recv(&buffer[0], size, MPI_DOUBLE, 1, tag, MPI_COMM_WORLD, &status);
	   double tend = MPI_Wtime();
	   double total_time = tend - tstart;
	   std::cout << size*sizeof(double) << "\t" << total_time << "\t" << size*sizeof(double)/total_time/1.0e6 << std::endl;
	 }
	 else { /* slaves only send */
	   MPI_Recv(&buffer[0], size, MPI_DOUBLE, 0, tag, MPI_COMM_WORLD, &status);
	   MPI_Send(&buffer[0], size, MPI_DOUBLE, 0, tag, MPI_COMM_WORLD);
	 }
       }
     }
   #+end_src
   And, after compiling, you can run it as
   #+begin_src shell
     for b in $(seq 2 28); do for a in $(seq 2 28) ; do echo -n "$b $a "  ; mpirun -np 2 --oversubscribe --host sala$b,sala$a ./a.out 2 10000000 | tail -n 1; done; echo ""; done | tee bw.txt
   #+end_src
   Final results will be collected in file =bw.txt= . 
* Problems and solutions [11/11]
** DONE Solving problems with xinit and xfce for all and new users
CLOSED: [2020-02-29 Sat 19:27]
- Make sure all users are on the video group. Maybe run
  #+BEGIN_SRC bash
usermod -a -G audio,cdrom,floppy,plugdev,video,power,netdev,lp,scanner USERNAME
  #+END_SRC
  on each user.
- Make sure that the minimum gid in yp nis is 2 (see file =/var/yp/Makefile=)

** DONE Dhcpcd                                                    :SLACKWARE:
CLOSED: [2019-10-16 Wed 10:25]
The latest slackware version advertises the nic using a new
identity called iuad or something but the dhcp server at unal does
not read it so I needed to edit the /etc/dhcpcd.conf file and
activate sending the hardware address. Done at the config slackware script.
** DONE Advertising Ethernet speeds for eth1
   CLOSED: [2019-10-16 Wed 10:25]
(Slackware does not have this problem)
The connection from/to server through eth1 was at a maximum of
10MB/s. while the interface supported gigabit. After many tests I
found that by using the command
#+begin_src shell
ethtool -s eth1 advertise 0x010
#+end_src
I was able to advertise up to gigabit and then run at 100MB/s, which
is the least acceptable given the router.

For slackware I added this to the minute_maintenance.sh .

To make this command permanent in debian, I had to add the following
line under the config for ~eth1~ in the file
~/etc/network/interfaces~
#+begin_src shell
post-up /sbin/ethtool -s eth1 advertise 0x010
#+end_src
** DONE Setup dropbox
#+begin_src sh
~/miniconda3/bin/python ~/dropbox.py proxy manual http proxyapp.unal.edu.co 8080 USERNAME PASSWORD
#+end_src
** DONE Instalando paquetes en R desde una cuenta de usuario
Para instalar paquetes desde una cuenta de usuario se usa el comando
normal ~install.packages~ . Pero si se hace desde un computador de
la universidad, es necesario configurar el proxy antes de entrar a
~R~.

*Nota*: Una vez instalados los paquetes no es necesario volver a
instalarlos, pero cada usuario debe instalar sus paquetes en su
cuenta.

*** Configuración del proxy
Existen dos formas de hacerlo. La primera, es la mas sencilla pero
debe hacerse cada vez que se abra una consola nueva. Esta primera
forma consiste en exportar las variables del proxy de la siguiente
manera
#+BEGIN_SRC sh :exports code
export http_proxy="http://USERNAME:PASSWORD@proxyapp.unal.edu.co:8080/"
export https_proxy="http://USERNAME:PASSWORD@proxyapp.unal.edu.co:8080/"
export ftp_proxy="http://USERNAME:PASSWORD@proxyapp.unal.edu.co:8080/"
#+END_SRC
en donde se debe reemplazar =USERNAME= por el nombre del usuario
(de la universidad, sin incluir @unal.edu.co) y =PASSWORD= es el password de
la universidad. En adelante podrá navegar por la consola. Se se
desea que estos comandos siempre se ejecuten al abrir una consola,
se pueden copiar al final del archivo =~/.ḃashrc= .

La segunda forma consiste en añadir el proxy a la información del
profile de =R=. Para esto, debe abrir el archivo oculto
=~.Renviron= (se puede abrir desde el mismo =R= usando el comando
=file.edit('~˙Renviron')=, y escribir allí
#+BEGIN_SRC sh
http_proxy=http://USERNAME:PASSWORD@proxyapp.unal.edu.co:8080/
http_proxy_user=USERNAME:PASSWORD

https_proxy=https://USERNAME:PASSWORD@proxyapp.unal.edu.co:8080/
https_proxy_user=USERNAME:PASSWORD
#+END_SRC
con la convención ya explicada. Este archivo es leido por =R= y por
=R studio=. En adelante, cada vez que se ejecute =R= se cargarán
estas variables.

*** Instalación de paquetes
En este caso simplemente se debe entrar a =R= y ejecutar el comando
#+BEGIN_SRC sh
install.packages(c("ggplot", "dplyr", "p", "rgeos", "digest", "foreign"), repos="https://www.icesi.edu.co/CRAN/")
#+END_SRC
Ese repositorio/mirror está ubicado en Colombia y es rápido, pero se puede
usar cualquier otro.

Los paquetes quedaran instalados en las cuentas locales de los usuarios.
** DONE Formating usb (recovering the usb)
Use gdisk
  #+begin_src sh
   gdisk
   enter recovery
   c
   e
   v
   w
   q
  #+end_src
  #+begin_src sh
   parted /dev/sdb
   mklabel GPT # accept destroying everything
  #+end_src
  Also you can use =cgdisk=.

  To completely delete the fs signatures
  #+begin_src 
   wipefs --all --force /dev/sdb
  #+end_src
** DONE [OLD] Installation  and setup of gdb numpy
   CLOSED: [2019-10-16 Wed 10:30]
  Anaconda creates a lot of problems. It is necessary to clean the path. The command I used was:
  #+begin_src shell
  kash ". ~/.bashrc; . /home/oquendo/PATH.sh; installpkg /home/oquendo/Downloads/pip-9.0.1-x86_64-1_SBo.tgz; pip install matplotlib numpy; cd /home/oquendo/Escritorio/HerrComp/05-Debugging/gdb_numpy-1.0/; python setup.py install"
  #+end_src
  
** DONE [OLD] Anaconda problems with qt
   CLOSED: [2019-10-16 Wed 10:31]
  If some error like "Cannot run ... QT ... xcb plugin ... " appears,
  maybe it needs to fix permissions. Run the following command:
  #+begin_src shell
  sudo chmod 755 /opt/anaconda2/bin/qt.conf
  #+end_src
** DONE [OLD] Ubuntu and related
*** Update git
   #+BEGIN_SRC sh
STATUS="$(grep -re wheezy-backports /etc/apt/sources.list | grep -v grep)"
if [ x"${STATUS}" == x ]; then
    echo "deb http://ftp.debian.org/debian wheezy-backports main" >> /etc/apt/sources.list
fi

apt-get update 

apt-get -t  wheezy-backports install "git" -y   
   #+END_SRC
  
** DONE [OLD] Armadillo problems with anaconda
 When installing armadillo, it finds the anaconda MKL and then a lot
 of problems arise when trying to run progrms with armadillo. This
 happens because putting anaconda bin on the path, in the first
 place, "overwrites" pkgconfig and many other system
 commands. Solution? eliminate anaconda from the path and then use
 alias or simething similar, like linking anaconda python, ipython,
 etc to /usr/local/bin, and no more.

** DONE [OLD] sbopkg behing firewall blocking rsync
   From : https://www.linuxquestions.org/questions/slackware-14/sbopkg-problem-774301/
   1. Download & install TOR from www.torproject.org
   2. Install polipo & torsocks
   3. Run "sudo torsocks sbopkg -r"
   4. Done, repository synced!

* PACKAGES
  This section is used to configure packages that have been already
  installed using the scripts inside the
  [[file:~/repos/computer-labs/packages/]] folder.  Hopefully every
  package will be installed using slpkg.

  - SlackBuild builder: https://alien.slackbook.org/AST/index.php
  - https://blog.spiralofhope.com/15906/slackware-package-managers.html
  - https://blog.spiralofhope.com/22995/checkinstall.html
  - slacktrack:
    https://www.reddit.com/r/slackware/comments/36flus/practices_for_package_maintenance_for_slackware/
  - src2pkg: https://distro.ibiblio.org/amigolinux/download/src2pkg/
  - https://idlemoor.github.io/slackrepo/links.html

** Auxiliary packages
Add alien repo to slpkg and then install libreoffice poppler-compat inkscape vlc
** Spack
   - clone it
   - source env
   - Setup http proxy in .curlrc as proxy = http://user,,,,
   - bootstrap
   - resource env and add this to bashrc
   - Install whatever
   - load whatever with modeule load
   - make an example
** CDO [2019-09-18 Wed]
   Use alien AST
** GRADS [2019-09-18 Wed]
   Use alien AST
** Tortoisehg 2018
   Download the source code (and maybe use src2pkg) and install the
   package. See https://tortoisehg.bitbucket.io/download/source.html
** [OLD] Squid
  #+begin_src sh
   # only access from localhost is allowed
acl localhost src 127.0.0.1/32
acl all src all
http_access allow localhost
http_access deny all
icp_access deny all

never_direct allow all

# turn off cache
cache_dir null /tmp
cache deny all

# logs
access_log /var/log/squid/access.log squid

# turn off proxy-headers (no idea what is it :))
via off
forwarded_for off

# describe external proxy server
cache_peer 168.176.239.30 parent 8080 0 no-query default proxy-only login=fisicasop_fcbog:PASSWD
http_port 10000
acl port10000 myport 10000
cache_peer_access 168.176.239.30 allow port10000
  #+end_src
* Todo [0/3]
  - [ ] ldap for auth: link with unal server
  - [ ] Check for possible VPN, maybe using wireguard, so to be able to browse internal clients
    - https://github.com/gsliepen/tinc/tree/1.1
    - https://tailscale.com/
    - https://github.com/slackhq/nebula
    - https://github.com/wiretrustee/wiretrustee
  - [ ] Check bandwidth for udpcast
    https://sandilands.info/sgordon/using-multicast-on-a-lan-in-linux
    Server
    #+begin_src
  dd if=/dev/urandom of=rand.bin bs=1M count=1000
  udp-sender --interface eth1 --broadcast --file rand.bin
    #+end_src
    Clients
    #+begin_src
  udp-receiver --file rand.bin
    #+end_src

    NOTE: For one client, bandwidth is maximized to 1000, for two or more, is
    inmediatly droped to 10.

    Checking with iperf3
    #+begin_src shell
  Servidor: iperf3 -s
  Cliente (tcp): iperf3 -c ${IPSERVER} -f m -i 1 -t 5
  Cliente (udp): iperf3 --udp -b 0 -c ${IPSERVER} -f m -i 1 -t 5
    #+end_src
    - [ ] Nvidia on server and clients
      Nvidia card on server salafis
      https://docs.slackware.com/howtos:hardware:proprietary_graphics_drivers
      https://forums.developer.nvidia.com/t/gpu-cooler-running-on-high-speed-all-the-time/48733
      nvidia-settings -q all | grep -i fan
      #nvidia-settings -a 'GPUTargetFanSpeed=50'
      https://en.altlinux.org/How_to_keep_the_GPU_(and_CPU)_cooler
  - check
     # https://www.reddit.com/r/linuxadmin/comments/nml66p/tools_you_use_on_a_daily_basis/
     iostat -dxk
     ncdu
     bashtop 
  - Ansible
    - https://docs.ansible.com/ansible/latest/collections/ansible/builtin/index.html
    - https://docs.ansible.com/ansible/latest/collections/index.html#list-of-collections
    - https://opensource.com/article/20/10/ansible-modules-linux
    - https://github.com/lightbulbjim/slackible?ref=https://githubhelp.com
    - https://docs.ansible.com/ansible/latest/collections/community/general/slackpkg_module.html
